#                                                                          +:                       
#                            .:.            `--://.                       ++/ `-:::////:`           
#                .-::::       -o+:       `:///+/-`                       :+o-/o//:-.`               
#               .+/:::o`       `+//`    -+//+/-`            ``...`       .o/oo::-.`                 
#               .++/::/+        `o:+`  :sooo+///++/:.`     -::::::.    .:::o//:////:`               
#                /+++/+y::-..`   :/+--++o+++++++//++++/-` -.:::::.-``-/:`  /+//```-/+`      .-`     
#                 osooo+::///:/:..oy++/::::-.```.-:://+++:o//::::/+-/:`     -+//   `/:   .:+/.      
#               `/ooooo+oo::::::oshs/-.///+++/:/oossoo/--/y++/:::y//.```...  -o+-    ``-++:`        
#              `ooo+so+++s.   `/++h+//oo++/-os//+--+s+///:s++:::os/:///+/:.   /+:   `-+o:`          
#              o+-` .y++//s` -o+++ys+/:/s.  /yo+///o++++ooss/:::ho++/-.       `s-  .++:`            
#              -     /o+/:/o.s++++yos+/:/o. .sss+/s++:. .ss+/:-oso+/:::-----.  :  :o:```            
#                     s/+/:/ho++++yooso//:o. sosy+yo-    +++::-s   `.-:/+++:/    os//+++//:-`       
#                     -o++::yoo++o.yooss+//o.+o/o:o/+`   s+/:-+:        s++s. ./:------:///://`     
#                      +//:+sso+o- +o+++ss//o:s:+`.o//  `s+/:-y        /+:o/s/-            .://-    
#                       o:/ossso/  `y+::/s/o+oy/:: .o+` +++:-:o    ./:`s//o/:`                :o.   
#                       `s/sosso    oo/::+.-ooh+:+` .+: s//:-o-  -/// ++:s/..-`                .:   
#                        :osooy:    -s+:--/ `+ho+o//-:-:o+/:-y `/+/:`:s++s+/-`      `.......        
#     `..``        --     ssss+s     s+/:-o  `+s/+.-/:`s//:-:s-+++//+ooos.```     ./+++////://-`    
#   `////++/:-`    -+/    -yss:+:.:-`/o/:-+.  `s/:: -o/++/:-+sssoo+oo+/:+  //    /s+:--.`   ````    
#      ``.-:///:.   +:-    yh/::s.`:++y+:-:/   o+-/  +s/+:::shs+/-.o///+: -+: `:/os+//++/:.`        
#        ````-://:  +::    +y+::+s` `/yo/:-+   /o-+ `//+/:/+s:.`   s/::o` /o-/+-  .++.`.:/+/:`      
#    `-//+++//:/oo/.+:     :o+/:+++   oo//:o   :s:+ :/:///:o-     `y/:o.  /s+-     `+o   `-///-     
#   :+/::--....-:+oo-      .s+/:+/+/  -s+:-/-  `y/o`-o/::::s      ++::+  -+/`       `s.     .//:    
#   `        -+oo/-.+/`     o//:/::s   y+/:-/   s+/:.s+:::o:  +. `y/:o.`/o-          .`       -o.   
#          .oo:`     -o/`   `s+/:::s   o+/:-+   o+:/.s+:::s   +o o+/-s.oo/--.`                 ./   
#         .+.         `/o:   /++:::y   -s+o+s.  ++/+-s/:-+:   +o/oo++oo/::---`                  `   
#                       -++. `y+/:-o-   yo:/+oo/+o:+/o/:-y    y+ys+++y:                             
#                        `++: o+/:-:o   o+/:-o+++s/os+/-:o   +sos//:+:                  `           
#                          :+/:o+:--s`  :so/:+ -++oyy+:-+: `+o/os+++s.           `..-://.           
#                .//++//:-. -+oy+/:-:o  `yooos+::soh++:-o-:o-  /o+/s/+:      `-:+++/:-`             
#       ./`        ``.-:+oo+::oh+/:--o-  s+/:+::+yys+/:-+o+`   o+/:s `:-   .-//:-.``                
#        ++:`    .       `.:++oh++::-:s` +o///:  oy/+/:-:s`    s/::o    .://++/-.`                  
#        `/+/:.  +-          `-y/++++:// -s+::/  /h::::::/    .s+:// `.//.  `.-///:.                
#          .////.//`           -o::::::o `y+::+  :h+/:::o.    o+/:+/.//.        .://-               
#            `-:o:++`           /++/:::s  s+::o  -ho+:::y `-`-o+::/s+/.```        `:+.              
#           `-/+++//+:-``        s//::-s` oo/:o  `ho+:::y/o: o/+//oso+++//:-`       -:              
#         `:oo/-     .-//:.`     /++/:-+: /o/:o` `ho+:-:h+.  o//::o`.-:/++////.                     
#        `o+- +-        .-//:.   `s+/:-:o -s/:+.  d++:-:y`   s+/:o:      .:+o/+/                    
#        o:   ./+:-` `.....:+//-` s/+:--s``y+:/:  d/+:-/+    s+/:y          `-/oo`                  
#              .+o:--.......---///s/+/:-:o y+:/:  y/+:-/+    y+/:o              :+                  
#           `:oy+y/-           `:sh++/:::o.s+///  y//:-:o   .s+://                `                 
#       `.:+o+:o/o+//.           .s///++/++s+::/ .s+/:-:o   /+/:+-                                  
#   .:/+++/-` :+//.//+/-..        `o:/:-:/+s+::/ +++/:--s   s//-o-                                  
#     ```     -o++  `.---.`        o//::::os+::/`o++::--o` .s+/-o-                                  
#              o+o                 /o+/::-ss+:://://::::// +++/:+-                                  
#              .oo-                -s++::-sy+::/.o:://:-o. s////o-                                  
#               .+o                `s++::-oh+::/ ++/:::/+  s///:s`                                  
#                `:-                y++::-:h+:/: .s+::-o-  y+/:/o                                   
#                                  `y++::--y+:/- `y+/:-s` .s+/:o-                                   
#                                  .s++:::-o+:/` .s+/:-o. /++::s.                           
#                                  :/+/:::--:..  /++::-/: s/+::s`                           
#                                    `````       ..-..`  `.--..-`  
#              _______       __       ___      ___  _______     ______      ______    
#             |   _  "\     /""\     |"  \    /"  ||   _  "\   /    " \    /    " \   
#             (. |_)  :)   /    \     \   \  //   |(. |_)  :) // ____  \  // ____  \  
#             |:     \/   /' /\  \    /\\  \/.    ||:     \/ /  /    ) :)/  /    ) :) 
#             (|  _  \\  //  __'  \  |: \.        |(|  _  \\(: (____/ //(: (____/ //  
#             |: |_)  :)/   /  \\  \ |.  \    /:  ||: |_)  :)\        /  \        /   
#             (_______/(___/    \___)|___|\__/|___|(_______/  \"_____/    \"_____/    
#                                                                   by Max Zabuty
    

# Constants
$Global:Intro = @" 
                                             
        YYYYYYY              YYYYYYY 
         YYYYYYY            YYYYYYY    
          YYYYYYY          YYYYYYY      
           YYYYYYY        YYYYYYY      
            YYYYYYY      YYYYYYY        
             YYYYYYY    YYYYYYY          
              YYYYYYY  YYYYYYY           
               YYYYYYY YYYYYY            
                YYYYYYYYYYYY            
                 YYYYYYYYYY               
                  YYYYYYYY                
                   YYYYYY  
                    YYYY                                
                    YYYY                  
                    YYYY                  
                                    
                    YYYY                 
                    YYYY                 
                    YYYY                  
               
                                                                               
"@
$Global:ProfileDate             = $(Get-Date -Format "dd-MM-yyyy_HH.mm.ss")
$Global:GeneralPath             = "$((Get-Location).Path)\$($env:COMPUTERNAME)-$($ProfileDate)"
$Global:LogPath                 = "$GeneralPath\$($env:COMPUTERNAME)-$($ProfileDate).log"
$Global:ConfigPath              = "$((Get-Location).Path)\config.ini"
$Global:ZipPath                 = "$((Get-Location).Path)\$($env:COMPUTERNAME)-$($ProfileDate).zip"
$Global:SystemInformationFolder = "$GeneralPath\System Information"
$Global:ProgramExecutionFolder  = "$GeneralPath\Program Execution"
$Global:FileDownloadFolder      = "$GeneralPath\File Download"
$Global:NetworkActivityFolder   = "$GeneralPath\Network Activity"
$Global:FileUsageFolder         = "$GeneralPath\File and Folder Usage"
$Global:OfficeForensics         = "$FileUsageFolder\Office Documents Usage"
$Global:USBUsageFolder          = "$GeneralPath\USB and External Device Usage"
$Global:BrowserUsageFolder      = "$GeneralPath\Browser Usage"
$Global:PersistenceFolder       = "$GeneralPath\Persistence Artifacts"
$Global:AdditionalFolder        = "$GeneralPath\Additional Files"
$Global:CloudFolder             = "$GeneralPath\Cloud Storage"
$Global:RegistryHives           = "$GeneralPath\Registry Hives"
$Global:config                  = @{}
$Global:ProgressPreference      = 'SilentlyContinue'
$Global:ErrorActionPreference   = "Stop"

function Check-AdminPrivileges{
    try{
    $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()

    $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)

    $isAdmin = $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
    }
    catch{
        # Handle specific errors here
        $errorMessage = "Check-AdminPrivileges Error: $($_.Exception.Message)"

        # Append the error message to the error log file
        Write-ErrorLog -Content $errorMessage

        return $true
    }

    if ($isAdmin) {
        return $true
    } else {
        return $false
    }
}

function Convert-SIDToUser{ 
    Param([String]$SID)

    try{
        $objSID = New-Object System.Security.Principal.SecurityIdentifier($SID)
        $objUser = $objSID.Translate([System.Security.Principal.NTAccount]) 
    }
    catch{
        # Handle specific errors here
        $errorMessage = "Convert-SIDToUser Error: $($_.Exception.Message)"

        # Append the error message to the error log file
        Write-ErrorLog -Content $errorMessage
    }
    return $objUser.Value
}

function Get-SIDs{
    try{
        $sids = gp 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\*' | ?{$_.PSChildName -match $PatternSID} | Select @{name="SID";expression={$_.PSChildName}},@{name='UserHive' ;expression={"$($_.ProfileImagePath)\ntuser.dat"}},@{name="Username";expression={$_.ProfileImagePath -replace '^(.*[\\\/])',''}}
    }
    catch{
        # Handle specific errors here
        $errorMessage = "Get-SIDs Error: $($_.Exception.Message)"

        # Append the error message to the error log file
        Write-ErrorLog -Content $errorMessage
    }
    return $sids
}

function Get-Users{
    return (Get-SIDs).Username
}

function Load-UserSids{
    #Regular Expression for SID
    $Global:PatternSID = 'S-1-5-21-\d+-\d+\-\d+\-\d+$'

    # Get Username, SID, and location of ntuser.dat for all users
    $Global:ProfileList = Get-SIDs

    # Get all user SIDs found in HKEY_USERS (ntuser.dat files located)
    $Global:LocalHives = gci Registry::HKEY_USERS | ? {$_.PSChildName -match $PatternSID} | Select @{name="SID";expression={$_.PSChildName}}

    # Get all users that are not currently logged
    $Global:UnloadedHives = Compare-Object $ProfileList.SID $LocalHives.SID | Select @{name="SID";expression={$_.InputObject}}

    # Loop through each profile on the machine
    foreach($item in $ProfileList){
        # Load user ntuser.dat if its not already loaded
        if($item.SID -in $UnloadedHives.SID){
            try{
                reg load HKU\$($item.SID) $($item.UserHive) | Out-Null
            }
            catch{
                # Handle specific errors here
                $errorMessage = "Load-UserSids Error: $($_.Exception.Message)"

                # Append the error message to the error log file
                Write-ErrorLog -Content $errorMessage
            }
        }
    }
}

function Unload-UserSids{
    # Loop through each profile on the machine 
    foreach($item in $ProfileList){
        try{
            # Unload user ntuser.dat of all users which are not logged
            if($item.SID -in $UnloadedHives.SID){
                [gc]::Collect()
                reg unload HKU\$($item.SID) | Out-Null
            }
        }
        catch{
            # Handle specific errors here
            $errorMessage = "Unload-UserSids Error: $($_.Exception.Message)"

            # Append the error message to the error log file
            Write-ErrorLog -Content $errorMessage
        }
    }
}

function Add-RegKeyLastWriteTime {
[CmdletBinding()]
param(
    [Parameter(Mandatory, ParameterSetName="ByKey", Position=0, ValueFromPipeline)]
    # Registry key object returned from Get-ChildItem or Get-Item
    [Microsoft.Win32.RegistryKey] $RegistryKey,
    [Parameter(Mandatory, ParameterSetName="ByPath", Position=0)]
    # Path to a registry key
    [string] $Path
)

 begin {
    # Define the namespace (string array creates nested namespace):
    $Namespace = "HeyScriptingGuy"

    # Make sure type is loaded (this will only get loaded on first run):
    Add-Type @"
        using System;
        using System.Text;
        using System.Runtime.InteropServices;

        $($Namespace | ForEach-Object {
            "namespace $_ {"
        })
            public class advapi32 {
                [DllImport("advapi32.dll", CharSet = CharSet.Auto)]
                public static extern Int32 RegQueryInfoKey(
                    Microsoft.Win32.SafeHandles.SafeRegistryHandle hKey,
                    StringBuilder lpClass,
                    [In, Out] ref UInt32 lpcbClass,
                    UInt32 lpReserved,
                    out UInt32 lpcSubKeys,
                    out UInt32 lpcbMaxSubKeyLen,
                    out UInt32 lpcbMaxClassLen,
                    out UInt32 lpcValues,
                    out UInt32 lpcbMaxValueNameLen,
                    out UInt32 lpcbMaxValueLen,
                    out UInt32 lpcbSecurityDescriptor,
                    out System.Runtime.InteropServices.ComTypes.FILETIME lpftLastWriteTime
                );
            }
        $($Namespace | ForEach-Object { "}" })
"@
   
    # Get a shortcut to the type:   
    $RegTools = ("{0}.advapi32" -f ($Namespace -join ".")) -as [type]
}
 process {
    switch ($PSCmdlet.ParameterSetName) {
        "ByKey" {
            # Already have the key, no more work to be done 🙂
        }
        "ByPath" {
            # We need a RegistryKey object (Get-Item should return that)
            $Item = Get-Item -Path $Path -ErrorAction Stop
 
            # Make sure this is of type [Microsoft.Win32.RegistryKey]
            if ($Item -isnot [Microsoft.Win32.RegistryKey]) {
                throw "'$Path' is not a path to a registry key!"
            }
            $RegistryKey = $Item
        }
    }
 
    # Initialize variables that will be populated:
    $ClassLength = 255 # Buffer size (class name is rarely used, and when it is, I've never seen
                        # it more than 8 characters. Buffer can be increased here, though.
    $ClassName = New-Object System.Text.StringBuilder $ClassLength  # Will hold the class name
    $LastWriteTime = New-Object System.Runtime.InteropServices.ComTypes.FILETIME 
           
    switch ($RegTools::RegQueryInfoKey($RegistryKey.Handle,
        $ClassName,
        [ref] $ClassLength,
        $null,  # Reserved
        [ref] $null, # SubKeyCount
        [ref] $null, # MaxSubKeyNameLength
        [ref] $null, # MaxClassLength
        [ref] $null, # ValueCount
        [ref] $null, # MaxValueNameLength
        [ref] $null, # MaxValueValueLength
        [ref] $null, # SecurityDescriptorSize
        [ref] $LastWriteTime
    )) {
         0 { # Success
            # Convert to DateTime object:
            $UnsignedLow = [System.BitConverter]::ToUInt32([System.BitConverter]::GetBytes($LastWriteTime.dwLowDateTime), 0)
            $UnsignedHigh = [System.BitConverter]::ToUInt32([System.BitConverter]::GetBytes($LastWriteTime.dwHighDateTime), 0)
            # Shift high part so it is most significant 32 bits, then copy low part into 64-bit int:
            $FileTimeInt64 = ([Int64] $UnsignedHigh -shl 32) -bor $UnsignedLow
            # Create datetime object
            $LastWriteTime = [datetime]::FromFileTime($FileTimeInt64)
 
            # Add properties to object and output them to pipeline
            $RegistryKey | Add-Member -NotePropertyMembers @{
                LastWriteTime = $LastWriteTime
                ClassName = $ClassName.ToString()
            } -PassThru -Force
        }
        122  { # ERROR_INSUFFICIENT_BUFFER (0x7a)
            throw "Class name buffer too small"
            # function could be recalled with a larger buffer, but for
            # now, just exit
        }
        default {
            throw "Unknown error encountered (error code $_)"
        }
    }
}
}

function Get-SystemInformation {
    $systemInfo = @{}
    
    # Host Name
    $systemInfo['Host Name'] = $env:COMPUTERNAME
    
    # OS Name
    $systemInfo['OS Name'] = (Get-CimInstance Win32_OperatingSystem).Caption
    
    # OS Version
    $systemInfo['OS Version'] = (Get-CimInstance Win32_OperatingSystem).Version

    # OS Architecture
    $systemInfo['OS Architecture'] = (Get-CimInstance Win32_Processor).AddressWidth.ToString() + "-Bit"
    
    # Original Install Date
    $systemInfo['Original Install Date'] = (Get-CimInstance Win32_OperatingSystem).InstallDate
    
    # System Boot Time
    $systemInfo['System Boot Time'] = (Get-CimInstance Win32_OperatingSystem).LastBootUpTime
    
    # System Manufacturer
    $systemInfo['System Manufacturer'] = (Get-CimInstance Win32_ComputerSystem).Manufacturer
    
    # System Model
    $systemInfo['System Model'] = (Get-CimInstance Win32_ComputerSystem).Model
    
    # BIOS Version
    $systemInfo['BIOS Version'] = (Get-CimInstance Win32_BIOS).SMBIOSBIOSVersion
    
    # Boot Device
    $systemInfo['Boot Device'] = (Get-CimInstance Win32_ComputerSystem).BootDevice
    
    # Time Zone
    $systemInfo['Time Zone'] = (Get-CimInstance Win32_TimeZone).Caption
    
    # Total Physical Memory (in GB)
    $totalPhysicalMemory = [math]::Round((Get-CimInstance Win32_ComputerSystem).TotalPhysicalMemory / 1GB)
    $systemInfo['Total Physical Memory'] = "$totalPhysicalMemory GB"
    
    # Domain
    $systemInfo['Domain'] = (Get-CimInstance Win32_ComputerSystem).Domain
    
    # Logon Server
    $systemInfo['Logon Server'] = (Get-CimInstance Win32_ComputerSystem).PrimaryOwnerName
    
    # Hotfix(s)
    $systemInfo['Hotfix(s)'] = (Get-HotFix).HotFixID -join ', '
    
    # Network Card(s)
    $networkAdapters = Get-CimInstance Win32_NetworkAdapterConfiguration | Where-Object { $_.IPEnabled }
    $networkCards = $networkAdapters | ForEach-Object { $_.Description }
    $systemInfo['Network Card(s)'] = $networkCards -join ', '
    
    # Create the output content in the specified order
    $output = @(
        "Host Name: $($systemInfo['Host Name'])",
        "OS Name: $($systemInfo['OS Name'])",
        "OS Version: $($systemInfo['OS Version'])",
        "OS Architecture: $($systemInfo['OS Architecture'])",
        "Original Install Date: $($systemInfo['Original Install Date'])",
        "System Boot Time: $($systemInfo['System Boot Time'])",
        "System Manufacturer: $($systemInfo['System Manufacturer'])",
        "System Model: $($systemInfo['System Model'])",
        "BIOS Version: $($systemInfo['BIOS Version'])",
        "Boot Device: $($systemInfo['Boot Device'])",
        "Time Zone: $($systemInfo['Time Zone'])",
        "Total Physical Memory: $($systemInfo['Total Physical Memory'])",
        "Domain: $($systemInfo['Domain'])",
        "Logon Server: $($systemInfo['Logon Server'])",
        "Hotfix(s): $($systemInfo['Hotfix(s)'])",
        "Network Card(s): $($systemInfo['Network Card(s)'])"
    )
    
    # Save the system information to a file
    $output | Out-File -FilePath "$SystemInformationFolder\System Information.txt" -Encoding UTF8
}

function Get-SysinternalsExecution{
    $Names = @()
    $sids = $ProfileList.SID 
    foreach($sid in $sids){
        try{
	        $user = ($ProfileList |  ?{$_.SID -eq $sid}).Username
        $Names += Get-ChildItem -Path Registry::HKU\$sid\Software\Sysinternals -ErrorAction SilentlyContinue | Add-RegKeyLastWriteTime | Sort -Descending LastWriteTime | Select @{name="LastWriteTime";expression={$_.LastWriteTime}},@{name="SID";expression={$sid}},@{name="Username";expression={$user}},@{name="Executable";expression={$_.PSChildName}}
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-SysinternalsExecution Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
        
    }
    return $Names
}

function Get-LocalUsers{
    if($PSVersionTable.PSVersion.Major -lt 5){
        $localusers = @()

        try{
			Add-Type -AssemblyName System.DirectoryServices.AccountManagement
        
            $PrincipalContext = New-Object System.DirectoryServices.AccountManagement.PrincipalContext([System.DirectoryServices.AccountManagement.ContextType]::Machine, $env:COMPUTERNAME)

            $usernames = (Get-WmiObject -Class Win32_UserAccount -Filter "LocalAccount=True").Name
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-LocalUsers Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        

        foreach($user in $usernames){
            try{
			    $info = [System.DirectoryServices.AccountManagement.UserPrincipal]::FindByIdentity($PrincipalContext, $user) | Select SID,Name,Description,Enabled,LastLogon,LastPasswordSet,PasswordNotRequired,UserCannotChangePassword,LastBadPasswordAttempt,PasswordNeverExpires
            
                $LocalUsers += $info
		    }
		    catch{
			    # Handle specific errors here
			    $errorMessage = "Get-LocalUsers Error: $($_.Exception.Message)"

			    # Append the error message to the error log file
			    Write-ErrorLog -Content $errorMessage
		    }
            
        }
        $localusers
    }
    else{
        try{
			$localusers = Get-LocalUser | Select SID,Name,Description,Enabled,LastLogon,PasswordLastSet,PasswordRequired,UserMayChangePassword,PasswordChangeableDate,PasswordExpires
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-LocalUsers Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
    }
    return $localusers
}

function Get-LocalGroups{
    if($PSVersionTable.PSVersion.Major -lt 5){
        $localgroups = Get-WmiObject -Class Win32_Group | Select Name,SID,Description
    }
    else{
        $localgroups = Get-LocalGroup | Select Name, SID, Description, ObjectClass, PrincipalSource
    }
    return $localgroups
}

function Get-TCPConnections{
    $connections = @()

    if($PSVersionTable.PSVersion.Major -lt 5){
        try{
            Get-NetTCPConnection | % {
                $members = [ordered]@{ 
                    "State"=$_.State;
                    "DNSCache"=(Get-DnsClientCache -Data $_.RemoteAddress -ea 0).Entry; 
                    "RemoteAddress"=$_.RemoteAddress;
                    "RemotePort"=$_.RemotePort;
                }
                $connections += New-Object psobject -Property $members
            }
			
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-TCPConnections Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
        
    }
    else{
        try{
			Get-NetTCPConnection | % {
                $members = [ordered]@{ 
                    "State"=$_.State;
                    "DNSCache"=(Get-DnsClientCache -Data $_.RemoteAddress -ea 0).Entry; 
                    "UserName"=(gps -Id $_.OwningProcess -IncludeUserName).UserName; 
                    "Process Name"=(gps -Id $_.OwningProcess).Name;
                    "Process Path"=(gps -Id $_.OwningProcess).Path; "OwningProcess"=$_.owningProcess;
                    "LocalAddress"=$_.LocalAddress;
                    "LocalPort"=$_.RemotePort;
                    "RemoteAddress"=$_.RemoteAddress;
                    "RemotePort"=$_.LocalPort;
                }
                $connections += New-Object psobject -Property $members
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-TCPConnections Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
        
    }
    return $connections
}

function Get-ProcessHashes{
    try{
		$hash_list = @()
        Get-WmiObject -Class Win32_Process | ?{$_.Path -ne $null} | %{
            $ProcessName = $_.Name
            $ProcessPath = $_.Path
            $ProcID = $_.ProcessID
            $hash5 = (certutil -hashfile $ProcessPath md5)[1]
            $hash1 = (certutil -hashfile $ProcessPath sha1)[1]
            $hash256 = (certutil -hashfile $ProcessPath sha256)[1]
            $list = [ordered]@{"ProcessName"=$ProcessName;"Path"=$ProcessPath;"PID"=$ProcID;"MD5"=$hash5;"SHA1"=$hash1;"SHA256"=$hash256}
            $hash_list += New-Object psobject -Property $list
        }
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Get-ProcessHashes Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    
    return $hash_list 
}

function Get-RecentDocs{
    $text = "UserName,Type,File,LastWriteTime`n"
    $RecentDocsPath = "\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs"
    $sids = $ProfileList.SID 

    foreach($sid in $sids){
        try{
		    $types = (Get-ChildItem -Path "Registry::HKU\$sid\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs" -ErrorAction SilentlyContinue).Name 
            foreach($type in $types){
                $LastAccessTime = (Get-Item -Path "Registry::$type" | Add-RegKeyLastWriteTime).LastWriteTime
                Get-Item -Path "Registry::$type" | Add-RegKeyLastWriteTime | Select-Object -ExpandProperty property | ?{$_ -notmatch "MRUListEx"} | ForEach-Object {
                    $i = [System.Text.Encoding]::Unicode.GetString((gp "Registry::$type" -Name $_).$_)
                    $i = $i -replace '[^a-zA-Zא-ת0-9 \. \-_\\/()~ ]', '\^'
                    $result = $i.split('\^')[0] 
                    if(!$result){$result="*Can't Decode The Text*"}
                    $text += "$(Convert-SIDToUser -SID $sid),$($type.Split("\")[-1]),$result,$LastAccessTime`n"
                }
            }	
	    }
	    catch{
		    # Handle specific errors here
		    $errorMessage = "Get-RecentDocs Error: $($_.Exception.Message)"
	
		    # Append the error message to the error log file
		    Write-ErrorLog -Content $errorMessage
	    }
    }

    return $text
}

function Get-RDPDirectConnectionsEventLog{
    $hosts = @()
    
    try{
		Get-WinEvent -Log 'Microsoft-Windows-TerminalServices-RDPClient/Operational' -ErrorAction SilentlyContinue | ?{$_.ID -eq 1102} | % {
            $ip = $_.Message.Split(" ")[-1]
            $ip = $ip.Substring(0,$ip.Length-1)
            $hostname = (Resolve-DnsName $ip -ErrorAction SilentlyContinue).NameHost
            $global:time = $_.TimeCreated
            $hosts += New-Object psobject -Property @{"Session Time"=$_.TimeCreated;"IP"=$ip;"Hostname"=$hostname}
        }
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Get-RDPDirectConnectionsEventLog Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    return $hosts
}

function Get-RDPConnectionsRegistry{
    $sessions = @()
    $sids = $ProfileList.SID 

    foreach($sid in $sids){

        try{
            $LastWriteTime = (Get-Item -Path "Registry::HKU\$sid\Software\Microsoft\Terminal Server Client\Default" -ErrorAction SilentlyContinue | Add-RegKeyLastWriteTime | Select LastWriteTime).LastWriteTime
            $user = ($ProfileList | ?{$_.SID -eq $sid}).Username
            $mrus = ((gp -Path "Registry::HKU\$sid\Software\Microsoft\Terminal Server Client\Default" -ErrorAction SilentlyContinue) | Get-Member -ErrorAction SilentlyContinue |?{$_.Name -match "MRU.*"}).Name 
            foreach($mru in $mrus){
                $session = (gp -Path "Registry::HKU\$sid\Software\Microsoft\Terminal Server Client\Default" -ErrorAction SilentlyContinue)."$mru"
                $sessions += gp -Path  "Registry::HKU\$sid\Software\Microsoft\Terminal Server Client\Default" -ErrorAction SilentlyContinue | Select @{name="SID";expression={$sid}},@{name="Username";expression={$user}},@{name="Session";expression={$session}},@{name="LastWriteTime";expression={$LastWriteTime}}
            }
			
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-RDPConnectionsRegistry Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }
    return $sessions
}

function Get-WinkeyRHistory{
    $history = @()

    $sids = $ProfileList.SID 
    foreach($sid in $sids){

        try{
			$user = ($ProfileList | ?{$_.SID -eq $sid}).Username
            $mrus = (gp -Path "Registry::HKU\$sid\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU" -ErrorAction SilentlyContinue).MRUList
            for($i=0;$i -le $mrus.Length-1;$i++){
                $Command = (gp -Path "Registry::HKU\$sid\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU" -ErrorAction SilentlyContinue)."$($mrus[$i])"
                $Command = $Command.Substring(0,$Command.Length-2)
                $history += gp -Path "Registry::HKU\$sid\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU" -ErrorAction SilentlyContinue | Select @{name="SID";expression={$sid}},@{name="Username";expression={$user}},@{name="Command";expression={$Command}} 
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-WinkeyRHistory Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }
    return $history
}

function Get-AllScheduledTasks{ 
    try{
        $tasks = ""
		$tasks = schtasks /query /V /FO CSV
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Get-AllScheduledTasks Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    return $tasks
}

function Copy-RecentFolders{
    $users = Get-Users
    foreach($user in $users){

        try{
			Copy-Item -Path "C:\Users\$user\AppData\Roaming\Microsoft\Windows\Recent" -Destination "$FileUsageFolder\Recent Files\$user" -ErrorAction SilentlyContinue -Recurse -Force 
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-RecentFolders Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        try{
			Copy-Item -Path "C:\Users\$user\AppData\Roaming\Microsoft\Office\Recent" -Destination "$OfficeForensics\Recent Office\$user" -ErrorAction SilentlyContinue -Recurse -Force
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-RecentFolders Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
        
    }
}

function Parse-JumpLists{
    $users = Get-Users

    try{
        $scriptPath = (Get-Location).Path

        Push-Location $scriptPath
    }
    catch{
		# Handle specific errors here
		$errorMessage = "Parse-JumpLists Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    foreach($user in $users){
        
        try{
			New-Item -Path "$ProgramExecutionFolder\Jump Lists" -ItemType Directory -Force | Out-Null

            New-Item -Path "$ProgramExecutionFolder\Jump Lists\$user" -ItemType Directory -Force | Out-Null

            New-Item -Path "$ProgramExecutionFolder\Jump Lists\$user\CustomDestinations" -ItemType Directory -Force | Out-Null

            New-Item -Path "$ProgramExecutionFolder\Jump Lists\$user\AutomaticDestinations" -ItemType Directory -Force | Out-Null
    
            if($config.'Forensic Action'.Parse -eq "yes"){./Dependencies/JLECmd.exe -d "C:\Users\$user\AppData\Roaming\Microsoft\Windows\Recent" --csv "$ProgramExecutionFolder\Jump Lists\$user" --csvf "$($user).tle" | Out-Null}

            if($config.'Forensic Action'.Collect -eq "yes"){
                Copy-Item -Path "C:\Users\$user\AppData\Roaming\Microsoft\Windows\Recent\CustomDestinations\*" -Destination "$ProgramExecutionFolder\Jump Lists\$user\CustomDestinations" -ErrorAction SilentlyContinue -Force -Recurse | Out-Null
        
                Copy-Item -Path "C:\Users\$user\AppData\Roaming\Microsoft\Windows\Recent\AutomaticDestinations\*" -Destination "$ProgramExecutionFolder\Jump Lists\$user\AutomaticDestinations" -ErrorAction SilentlyContinue -Force -Recurse | Out-Null
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Parse-JumpLists Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
        
    }

    Pop-Location
}

function Parse-SRUM{
    $users = Get-Users

    try{
        $scriptPath = (Get-Location).Path

        Push-Location $scriptPath
    }
    catch{
		# Handle specific errors here
		$errorMessage = "Parse-SRUM Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    New-Item -Path "$NetworkActivityFolder\SRUM" -ItemType Directory -Force | Out-Null

    try{
		if($config.'Forensic Action'.Collect -eq "yes"){Copy-ProtectedFiles -SourcePath "C:\Windows\System32\sru\SRUDB.dat" -DestinationPath "$NetworkActivityFolder\SRUM" | Out-Null}
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-SRUM Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    
    try{
	    if($config.'Forensic Action'.Parse -eq "yes"){./Dependencies/SrumECmd.exe -f "C:\Windows\System32\sru\SRUDB.dat" -r "$RegistryHives\SOFTWARE" --csv "$NetworkActivityFolder\SRUM"  --csvf| Out-Null}
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-SRUM Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    

    Pop-Location
}

function Parse-RecycleBins{

    $outputPath = "$FileUsageFolder\Recycle Bins"

    $shell = New-Object -Comobject Shell.Application

    $recycleBin = $Shell.Namespace(0xA)

    $recycled = @()

    $recycleBin.Items() | %{

        try{
			$originalPath = $_.ExtendedProperty("{9B174B33-40FF-11D2-A27E-00C04FC30871} 2")

            $originalRoot = [System.IO.Path]::GetPathRoot($originalPath)

            $newPath = $originalPath.Substring($originalRoot.Length)

            if($originalRoot -like '?:\*'){ $newRoot = $originalRoot.Substring(0,1)} else{ $newRoot=$originalRoot.Trim("\") -replace '\\', ' '}

            $newPath = Join-Path -Path $outputPath -ChildPath "$newRoot\$newPath" 

            $recycledPath = $_.Path

            if(Test-Path $recycledPath -PathType Container){$fileType = "Directory"}
            else{$fileType = "File"}

            $originalPath = (Join-Path -Path $newPath -ChildPath $_.Name)

            $sha1 = (Get-FileHash -Algorithm SHA1 -Path $recycledPath -ErrorAction SilentlyContinue).Hash

            $removalDate = (Get-Item -Path $_.Path -ErrorAction SilentlyContinue).CreationTime

            $recycleSid = $recycledPath.Split("\\")[2]

            $userName = ($ProfileList | ?{$_.SID -eq $recycleSid}).Username

            $properties = [ordered]@{
                "Removal Date"=$removalDate
                "Username"=$userName
                "Recycle Bin Path"=$recycledPath
                "Original Path"=$originalPath
                "File Type"=$fileType
                "SHA1"=$sha1
            }

            $recycled += New-Object psobject -Property $properties
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Parse-RecycleBins Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }

    [System.Runtime.InteropServices.Marshal]::ReleaseComObject($shell) | Out-Null 
    [System.GC]::Collect()
    [System.GC]::WaitForPendingFinalizers()
    $shell = $null

    return $recycled
}

function Copy-UnsavedOfficeFiles{
    $users = Get-Users

    foreach($user in $users){
        try{
			Copy-Item -Path "C:\Users\$user\AppData\Local\Microsoft\Office\UnsavedFiles" -Destination "$OfficeForensics\Unsaved Office Files\$user" -ErrorAction SilentlyContinue -Recurse -Force
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-UnsavedOfficeFiles Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
        
    }
}

function Copy-ChromeFiles{
    $users = Get-Users

    $files = @("History","Cookies","Login Data", "Visited Links", "Web Data", "Preferences")

    New-Item -ItemType Directory -Path $BrowserUsageFolder -Name "Chrome Files"  -ErrorAction SilentlyContinue | Out-Null

    foreach($user in $users){
        $ProfileFolder = Get-ChildItem "C:\Users\$user\AppData\Local\Google\Chrome\User Data\Profile *" -ErrorAction SilentlyContinue
        $DefaultProfileFolder = (Get-Item "C:\Users\$user\AppData\Local\Google\Chrome\User Data\Default" -ErrorAction SilentlyContinue).FullName

        if($ProfileFolder){
            New-Item -ItemType Directory -Path "$BrowserUsageFolder\Chrome Files" -Name $user | Out-Null
            foreach($profile in $ProfileFolder)
            {
                try{
			        New-Item -ItemType Directory -Path "$BrowserUsageFolder\Chrome Files\$user\$($profile.Name)" | Out-Null

                    $fullProfile = $profile.FullName

                    foreach($file in $files){
                        try{
			                Copy-Item -Path "$fullProfile\$file" -Destination "$BrowserUsageFolder\Chrome Files\$user\$($profile.Name)" -ErrorAction SilentlyContinue -Force
		                }
		                catch{
			                # Handle specific errors here
			                $errorMessage = "Copy-ChromeFiles Error: $($_.Exception.Message)"
		
			                # Append the error message to the error log file
			                Write-ErrorLog -Content $errorMessage
		                }
                        
                    }

                    Copy-Item -Path "$fullProfile\Cache" -Destination "$BrowserUsageFolder\Chrome Files\$user\$($profile.Name)" -Recurse -ErrorAction SilentlyContinue -Force
                    Copy-Item -Path "$fullProfile\Extensions" -Destination "$BrowserUsageFolder\Chrome Files\$user\$($profile.Name)" -Recurse -ErrorAction SilentlyContinue -Force
                    Copy-Item -Path "$fullProfile\Platform Notifications" -Destination "$BrowserUsageFolder\Chrome Files\$user\$($profile.Name)" -Recurse -ErrorAction SilentlyContinue -Force
                    
		        }
		        catch{
			        # Handle specific errors here
			        $errorMessage = "Copy-ChromeFiles Error: $($_.Exception.Message)"
		
			        # Append the error message to the error log file
			        Write-ErrorLog -Content $errorMessage
		        }
                
            }
            
        }

        if($DefaultProfileFolder){
            New-Item -ItemType Directory -Path "$BrowserUsageFolder\Chrome Files" -Name $user -ErrorAction SilentlyContinue | Out-Null
            New-Item -ItemType Directory -Path "$BrowserUsageFolder\Chrome Files\$user" -Name Default -ErrorAction SilentlyContinue | Out-Null

            try{
			    foreach($file in $files){
                    try{
			            Copy-Item -Path "$DefaultProfileFolder\$file" -Destination "$BrowserUsageFolder\Chrome Files\$user\Default" -ErrorAction SilentlyContinue -Force
		            }
		            catch{
			            # Handle specific errors here
			            $errorMessage = "Copy-ChromeFiles Error: $($_.Exception.Message)"
		
			            # Append the error message to the error log file
			            Write-ErrorLog -Content $errorMessage
		            }
                    
                }

                Copy-Item -Path "$DefaultProfileFolder\Cache" -Destination "$BrowserUsageFolder\Chrome Files\$user\Default" -Recurse -ErrorAction SilentlyContinue -Force
                Copy-Item -Path "$DefaultProfileFolder\Extensions" -Destination "$BrowserUsageFolder\Chrome Files\$user\Default" -Recurse -ErrorAction SilentlyContinue -Force
                Copy-Item -Path "$DefaultProfileFolder\Platform Notifications" -Destination "$BrowserUsageFolder\Chrome Files\$user\Default" -Recurse -ErrorAction SilentlyContinue -Force
                
		    }
		    catch{
			    # Handle specific errors here
			    $errorMessage = "Copy-ChromeFiles Error: $($_.Exception.Message)"
		
			    # Append the error message to the error log file
			    Write-ErrorLog -Content $errorMessage
		    }
        }
    }
}

function Copy-IEFiles{
    $users = Get-Users

    New-Item -ItemType Directory -Path $BrowserUsageFolder -Name "IE Files" -ErrorAction SilentlyContinue | Out-Null
    
    foreach($user in $users){

        try{
			$IEFilesPath = "C:\Users\$user\AppData\Local\Microsoft\Windows\WebCache"

            New-Item -ItemType Directory -Path "$BrowserUsageFolder\IE Files" -Name "$user" -ErrorAction SilentlyContinue | Out-Null

            Copy-ProtectedFiles -SourcePath "$IEFilesPath\WebCacheV01.dat" -DestinationPath "$BrowserUsageFolder\IE Files\$user"
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-IEFiles Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }

}

function Copy-FirefoxFiles{
    $users = Get-Users

    $files = @("places.sqlite","cookies.sqlite","downloads.sqlite","favicons.sqlite","formhistory.sqlite","logins.json","sessionstore.jsonlz4")

    New-Item -ItemType Directory -Path $BrowserUsageFolder -Name "Firefox Files"  -ErrorAction SilentlyContinue | Out-Null

    foreach($user in $users){

        try{
			$ProfileFolders = (Get-ChildItem "C:\Users\$user\AppData\Roaming\Mozilla\Firefox\Profiles\*" -ErrorAction SilentlyContinue).FullName

            New-Item -ItemType Directory -Path "$BrowserUsageFolder\Firefox Files" -Name $user | Out-Null

            foreach($folder in $ProfileFolders){
            

                foreach($file in $files){
                    try{
			            Copy-Item -Path "$folder\$file" -Destination "$BrowserUsageFolder\Firefox Files\$user" -ErrorAction SilentlyContinue -Force
		            }
		            catch{
			            # Handle specific errors here
			            $errorMessage = "Copy-FirefoxFiles Error: $($_.Exception.Message)"
		
			            # Append the error message to the error log file
			            Write-ErrorLog -Content $errorMessage
		            }

                    
                }
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-FirefoxFiles Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        

        
    }
}

function Copy-EdgeFiles{
    $users = Get-Users

    $files = @("History","Cookies","Bookmarks","Favicons","Login Data")

    New-Item -ItemType Directory -Path $BrowserUsageFolder -Name "Edge Files"  -ErrorAction SilentlyContinue | Out-Null

    foreach($user in $users){

        $ProfileFolder = (Get-Item "C:\Users\$user\AppData\Local\Microsoft\Edge\User Data\Default" -ErrorAction SilentlyContinue).FullName

        if($ProfileFolder){
            New-Item -ItemType Directory -Path "$BrowserUsageFolder\Edge Files" -Name $user | Out-Null

            foreach($file in $files){
                try{
			        Copy-Item -Path "$ProfileFolder\$file" -Destination "$BrowserUsageFolder\Edge Files\$user" -ErrorAction SilentlyContinue -Force
		        }
		        catch{
			        # Handle specific errors here
			        $errorMessage = "Copy-EdgeFiles Error: $($_.Exception.Message)"
		
			        # Append the error message to the error log file
			        Write-ErrorLog -Content $errorMessage
		        }

                
            }
            try{
			    Copy-Item -Path "$ProfileFolder\Cache" -Destination "$BrowserUsageFolder\Edge Files\$user" -ErrorAction SilentlyContinue -Force -Recurse
		    }
		    catch{
			    # Handle specific errors here
			    $errorMessage = "Copy-EdgeFiles Error: $($_.Exception.Message)"
		
			    # Append the error message to the error log file
			    Write-ErrorLog -Content $errorMessage
		    }
            
        }

    }
}

function Copy-EventLogs{
    $files = @("Application.evtx",
               "Security.evtx",
               "Microsoft-Windows-TerminalServices-RDPClient%4Operational.evtx",
               "Microsoft-Windows-RemoteDesktopServices-RdpCoreTS%4Operational.evtx",
               "Microsoft-Windows-TerminalServices-RemoteConnectionManager%4Operational.evtx",
               "Microsoft-Windows-TerminalServices-LocalSessionManager%4Operational.evtx",
               "microsoft-windows-terminalservices-rdpclient%4operational.evtx",
               "Microsoft-Windows-SmbClient%4Security.evtx",
               "Microsoft-Windows-WinRM%4Operational.evtx",
               "System.evtx",
               "Microsoft-Windows-TaskScheduler%4Operational.evtx",
               "Microsoft-Windows-WMI-Activity%4Operational.evtx",
               "Microsoft-Windows-PowerShell%4Operational.evtx",
               "Windows PowerShell.evtx",
               "Microsoft-Windows-Sysmon%4Operational.evtx",
               "Microsoft-Windows-Bits-Client%4Operational.evtx",
               "Microsoft-Windows-SMBServer%4Security.evtx")

    New-Item -ItemType Directory -Path $GeneralPath -Name "Event Logs" | Out-Null 

    foreach($file in $files){
        try{
			Copy-Item -Path "C:\Windows\System32\winevt\Logs\$file" -Destination "$GeneralPath\Event Logs" -Force -ErrorAction SilentlyContinue
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-EventLogs Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
        
    }
}

function Copy-TemporaryBurnFolders{
    $users = Get-Users

    foreach($user in $users){
        Copy-Item -Path "C:\Users\$user\AppData\Local\Microsoft\Windows\Burn\Burn" -Destination "$FileUsageFolder\Temporary Burn Folder\$user" -ErrorAction SilentlyContinue -Recurse -Force
    }
}

function Copy-DownloadsFolder{
    
    $users = Get-Users

    foreach($user in $users){

        try{
			New-Item -ItemType Directory -Path "$FileDownloadFolder\Downloads" -ErrorAction SilentlyContinue | Out-Null
            New-Item -ItemType Directory -Path "$FileDownloadFolder\Downloads\$user" -ErrorAction SilentlyContinue | Out-Null
            #New-Item -ItemType Directory -Path "$FileDownloadFolder\Downloads\$user\Downloaded Files" -ErrorAction SilentlyContinue | Out-Null

            if(Test-Path -Path "C:\Users\$user\Downloads"){
                $folder_size = (Get-ChildItem "C:\Users\$user\Downloads" | measure Length -s).sum / 1Mb

                $downloads = @()

                Get-ChildItem "C:\Users\$user\Downloads" -Recurse | %{
                    $userpath = $_.FullName

                    $zoneIdentifier = Get-Content -Path $userpath -Stream Zone.Identifier -ErrorAction SilentlyContinue

                    $ZoneId = "-"
                    $ReferrerUrl = "-"
                    $HostUrl = "-"
        
                    if($zoneIdentifier){
                        $zoneIdentifier = $zoneIdentifier -join "`n"

                        if ($zoneIdentifier -match "ZoneId=(.*?)\n") {
                            $ZoneId = $Matches[1]
                        }

                        if ($zoneIdentifier -match ".*ReferrerUrl=(.*)\n.*") {
                            $ReferrerUrl = $Matches[1]
                        }

                        if ($zoneIdentifier -match ".*HostUrl=(.*)") {
                            $HostUrl = $Matches[1]
                        }
                    }
        
                    $file_size = $_.Length / 1Mb
        
                    $properties = [ordered]@{
                        "Directory"=$_.Directory
                        "File Name"=$_.PSChildName
                        "Zone Id"=$ZoneId
                        "Referrer URL"=$ReferrerUrl
                        "Host URL"=$HostUrl
                        "File Size (Mb)"=$file_size
                        "Creation Time"=$_.CreationTime
                        "Last Accesss Time"=$_.LastAccessTime
                        "Last Write Time"=$_.LastWriteTime
                    }
        
                    $downloads += New-Object psobject -Property $properties
                }
            }

            
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-DownloadsFolder Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }
    if($downloads){$downloads | Export-Csv -Path "$FileDownloadFolder\Downloads\$user\Downloads.tle" -Force -Encoding UTF8 -NoTypeInformation}
}

function Copy-OutlookOpenedFiles{
    $users = Get-Users

    foreach($user in $users){
        try{
			Copy-Item -Path "C:\Users\$user\AppData\Local\Microsoft\Windows\INetCache\Content.Outlook" -Destination "$OfficeForensics\Outlook Opened Files History\$user" -ErrorAction SilentlyContinue -Recurse -Force
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-OutlookOpenedFiles Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
    }
}

function Copy-ProtectedFiles{
    param (
        [parameter(Mandatory=$true)]
        [string]$SourcePath,

        [parameter(Mandatory=$true)]
        [string]$DestinationPath
    )

    # Copy the file using the wanted utility
    try {
        .\Dependencies\RawCopy.exe /FileNamePath:"$SourcePath" /OutputPath:"$DestinationPath" | Out-Null
    } catch {
        # Handle specific errors here
		$errorMessage = "Copy-ProtectedFiles Error: $($_.Exception.Message)"
		
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
    }
}

function Get-TempFolders{
    $users = Get-Users

    $tmpfolder = "$FileUsageFolder\Temp Folders"

    New-Item -Path $tmpfolder -ItemType Directory -Force | Out-Null

    foreach($user in $users){

        try{
			Get-ChildItem -Path "C:\Users\$user\AppData\Local\Temp" -Recurse | Select-Object -Property CreationTimeUtc,LastWriteTimeUtc,FullName,BaseName | Export-Csv "$tmpfolder\$user Temp Folder.tle" -Encoding UTF8 -NoTypeInformation
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-TempFolders Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		} 
    }
    try{
        Get-ChildItem -Path "C:\Windows\Temp" -Recurse | Select-Object -Property CreationTimeUtc,LastWriteTimeUtc,FullName,BaseName | Export-Csv "$tmpfolder\Windows Temp Folder.tle" -Encoding UTF8 -NoTypeInformation
    }
    catch{
    	# Handle specific errors here
    	$errorMessage = "Get-TempFolders Error: $($_.Exception.Message)"
    
    	# Append the error message to the error log file
    	Write-ErrorLog -Content $errorMessage
    } 
}

function Get-USBConnections{
    $Paths = @("HKLM:\SYSTEM\CurrentControlSet\Enum\HID", 
                "HKLM:\SYSTEM\CurrentControlSet\Enum\USB", 
                "HKLM:\SYSTEM\CurrentControlSet\Enum\USBSTOR", 
                "HKLM:\SYSTEN\CurrentControlSet\Enum\PCI", 
                "HKLM:\SYSTEM\CurrentControlSet\Enum\DISPLAY", 
                "HKLM:\SYSTEM\CurrentControlSet\Enum\HDAUDIO")
    
    $UsbConns = @()
    
    foreach($curr_path in $paths){
    
        $HardwareIDs = (Get-ChildItem -Path $curr_path -ErrorAction SilentlyContinue).PSChildName
    
        foreach($hardwareId in $HardwareIDs){

            try{
			    $InstanceIDs = (Get-ChildItem -Path "$curr_path\$hardwareId" -ErrorAction SilentlyContinue).PSChildName 
            
                foreach($instanceId in $InstanceIDs){
                    $LastWriteTime = (Get-Item -Path "$curr_path\$hardwareId\$instanceId" | Add-RegKeyLastWriteTime).LastWriteTime 
                    $UsbProperty = Get-ItemProperty -Path "$curr_path\$hardwareId\$instanceId"
    
                    $Description = $UsbProperty.DeviceDesc.Split(";")[-1]

                    $HID = $UsbProperty.HardwareID[0]

                    $Service = $UsbProperty.Service

                    $FriendlyName = $UsbProperty.FriendlyName

                    $UsbConns += Get-ItemProperty -Path "$curr_path\$hardwareId\$instanceId" -ErrorAction SilentlyContinue | Select @{name="LastWriteTime";expression={$LastWriteTime}},@{name="Description";expression={$Description}},@{name="Friendly Name";expression={$FriendlyName}},@{name="HardwareID";expression={$HID}},@{name="InstanceID";expression={$instanceId}},@{name="Service";expression={$Service}}
                }
		    }
		    catch{
			    # Handle specific errors here
			    $errorMessage = "Get-USBConnections Error: $($_.Exception.Message)"
		
			    # Append the error message to the error log file
			    Write-ErrorLog -Content $errorMessage
		    }
        }
    }

    return $UsbConns
}

function Get-Services{
    $Services = (Get-ChildItem -Path "Registry::HKLM\SYSTEM\CurrentControlSet\Services" -ErrorAction SilentlyContinue).Name 

    $serviceList = @()
    foreach($service in $Services){

        try{
			$LastWriteTime = (Get-Item -Path "Registry::$service" | Add-RegKeyLastWriteTime).LastWriteTime
            $Name = Split-Path -Path $service -Leaf
            #Get-Item -Path "Registry::$service" | Add-RegKeyLastWriteTime | Select @{name="Name";expression={$_}},@{name="DisplayName";expression={$_.DisplayName}},@{name="Description";expression={$_.Description}},@{name="LastWriteTime";expression={$_.LastWriteTime}}
            $serviceList += Get-ItemProperty -Path "Registry::$service" | Select @{name="LastWriteTime";expression={$LastWriteTime}},@{name="Name";expression={$Name}},@{name="DisplayName";expression={$_.DisplayName}},@{name="Description";expression={$_.Description}},@{name="Image Path";expression={$_.ImagePath}},@{name="Username";expression={$_.ObjectName}}
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-Services Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		} 
    }
    return $serviceList | Sort -Descending LastWriteTime

}

function Get-MountPoints{
    $Names = @()
    
    $sids = $ProfileList.SID 
    
    foreach($sid in $sids){

        try{
			$user = ($ProfileList | ?{$_.SID -eq $sid}).Username

            $Names += Get-ChildItem -Path Registry::HKU\$sid\Software\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2 -ErrorAction SilentlyContinue | Add-RegKeyLastWriteTime | Sort -Descending LastWriteTime | Select @{name="LastWriteTime";expression={$_.LastWriteTime}},@{name="SID";expression={$sid}},@{name="Username";expression={$user}},@{ name="Executable";expression={$_.PSChildName}}

		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-MountPoints Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

            }
    return $Names
}

function Get-WindowsPortableDevices{

    $devices = @()

    Get-ChildItem -Path "Registry::HKLM\SOFTWARE\Microsoft\Windows Portable Devices\Devices" -ErrorAction SilentlyContinue | Add-RegKeyLastWriteTime | %{
        
        try{
			$Property = [ordered]@{ 
                "LastWriteTime"=$_.LastWriteTime 
                "Key"=$_.PSChildName
                "FriendlyName"=(gp "Registry::$($_.Name)").FriendlyName
            }


            $devices += New-Object psobject -Property $Property
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-WindowsPortableDevices Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }
    return $devices
}

function Collect-Autoruns{

    try{
        $scriptPath = (Get-Location).Path

        Push-Location $scriptPath
    }
    catch{
		# Handle specific errors here
		$errorMessage = "Collect-Autoruns Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    try{
        ./Dependencies/autorunsc.exe /accepteula -nobanner -a * -c -h -s '*' > "$PersistenceFolder\Autoruns.tle"
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Collect-Autoruns Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    

    Pop-Location
}

function Parse-UserAssist{
    $userAssistRecords = @() 

    try{
        $guidPattern = New-Object System.Text.RegularExpressions.Regex "([A-Fa-f0-9]{8}(?:-[A-Fa-f0-9]{4}){3}-[A-Fa-f0-9]{12})"

        $GUIDKnownFolderHT = @{
                "DE61D971-5EBC-4F02-A3A9-6C82895E5C04" = "AddNewPrograms"
                "724EF170-A42D-4FEF-9F26-B60E846FBA4F" = "AdminTools"
                "A520A1A4-1780-4FF6-BD18-167343C5AF16" = "AppDataLow"
                "A305CE99-F527-492B-8B1A-7E76FA98D6E4" = "AppUpdates"
                "9E52AB10-F80D-49DF-ACB8-4330F5687855" = "CDBurning"
                "DF7266AC-9274-4867-8D55-3BD661DE872D" = "ChangeRemovePrograms"
                "D0384E7D-BAC3-4797-8F14-CBA229B392B5" = "CommonAdminTools"
                "C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D" = "CommonOEMLinks"
                "0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8" = "CommonPrograms"
                "A4115719-D62E-491D-AA7C-E74B8BE3B067" = "CommonStartMenu"
                "82A5EA35-D9CD-47C5-9629-E15D2F714E6E" = "CommonStartup"
                "B94237E7-57AC-4347-9151-B08C6C32D1F7" = "CommonTemplates"
                "0AC0837C-BBF8-452A-850D-79D08E667CA7" = "Computer"
                "4BFEFB45-347D-4006-A5BE-AC0CB0567192" = "Conflict"
                "6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD" = "Connections"
                "56784854-C6CB-462B-8169-88E350ACB882" = "Contacts"
                "82A74AEB-AEB4-465C-A014-D097EE346D63" = "ControlPanel"
                "2B0F765D-C0E9-4171-908E-08A611B84FF6" = "Cookies"
                "B4BFCC3A-DB2C-424C-B029-7FE99A87C641" = "Desktop"
                "FDD39AD0-238F-46AF-ADB4-6C85480369C7" = "Documents"
                "374DE290-123F-4565-9164-39C4925E467B" = "Downloads"
                "1777F761-68AD-4D8A-87BD-30B759FA33DD" = "Favorites"
                "FD228CB7-AE11-4AE3-864C-16F3910AB8FE" = "Fonts"
                "CAC52C1A-B53D-4EDC-92D7-6B2E8AC19434" = "Games"
                "054FAE61-4DD8-4787-80B6-090220C4B700" = "GameTasks"
                "D9DC8A3B-B784-432E-A781-5A1130A75963" = "History"
                "4D9F7874-4E0C-4904-967B-40B0D20C3E4B" = "Internet"
                "352481E8-33BE-4251-BA85-6007CAEDCF9D" = "InternetCache"
                "BFB9D5E0-C6A9-404C-B2B2-AE6DB6AF4968" = "Links"
                "F1B32785-6FBA-4FCF-9D55-7B8E7F157091" = "LocalAppData"
                "2A00375E-224C-49DE-B8D1-440DF7EF3DDC" = "LocalizedResourcesDir"
                "4BD8D571-6D19-48D3-BE97-422220080E43" = "Music"
                "C5ABBF53-E17F-4121-8900-86626FC2C973" = "NetHood"
                "D20BEEC4-5CA8-4905-AE3B-BF251EA09B53" = "Network"
                "2C36C0AA-5812-4B87-BFD0-4CD0DFB19B39" = "OriginalImages"
                "69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C" = "PhotoAlbums"
                "33E28130-4E1E-4676-835A-98395C3BC3BB" = "Pictures"
                "DE92C1C7-837F-4F69-A3BB-86E631204A23" = "Playlists"
                "76FC4E2D-D6AD-4519-A663-37BD56068185" = "Printers"
                "9274BD8D-CFD1-41C3-B35E-B13F55A758F4" = "PrintHood"
                "5E6C858F-0E22-4760-9AFE-EA3317B67173" = "Profile"
                "62AB5D82-FDC1-4DC3-A9DD-070D1D495D97" = "ProgramData"
                "905E63B6-C1BF-494E-B29C-65B732D3D21A" = "ProgramFiles"
                "F7F1ED05-9F6D-47A2-AAAE-29D317C6F066" = "ProgramFilesCommon"
                "6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D" = "ProgramFilesCommonX64"
                "DE974D24-D9C6-4D3E-BF91-F4455120B917" = "ProgramFilesCommonX86"
                "6D809377-6AF0-444B-8957-A3773F02200E" = "ProgramFilesX64"
                "7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E" = "ProgramFilesX86"
                "A77F5D77-2E2B-44C3-A6A2-ABA601054A51" = "Programs"
                "DFDF76A2-C82A-4D63-906A-5644AC457385" = "Public"
                "C4AA340D-F20F-4863-AFEF-F87EF2E6BA25" = "PublicDesktop"
                "ED4824AF-DCE4-45A8-81E2-FC7965083634" = "PublicDocuments"
                "3D644C9B-1FB8-4F30-9B45-F670235F79C0" = "PublicDownloads"
                "DEBF2536-E1A8-4C59-B6A2-414586476AEA" = "PublicGameTasks"
                "3214FAB5-9757-4298-BB61-92A9DEAA44FF" = "PublicMusic"
                "B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5" = "PublicPictures"
                "2400183A-6185-49FB-A2D8-4A392A602BA3" = "PublicVideos"
                "52A4F021-7B75-48A9-9F6B-4B87A210BC8F" = "QuickLaunch"
                "AE50C081-EBD2-438A-8655-8A092E34987A" = "Recent"
                "BD85E001-112E-431E-983B-7B15AC09FFF1" = "RecordedTV"
                "B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC" = "RecycleBin"
                "8AD10C31-2ADB-4296-A8F7-E4701232C972" = "ResourceDir"
                "3EB685DB-65F9-4CF6-A03A-E3EF65729F3D" = "RoamingAppData"
                "B250C668-F57D-4EE1-A63C-290EE7D1AA1F" = "SampleMusic"
                "C4900540-2379-4C75-844B-64E6FAF8716B" = "SamplePictures"
                "15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5" = "SamplePlaylists"
                "859EAD94-2E85-48AD-A71A-0969CB56A6CD" = "SampleVideos"
                "4C5C32FF-BB9D-43B0-B5B4-2D72E54EAAA4" = "SavedGames"
                "7D1D3A04-DEBB-4115-95CF-2F29DA2920DA" = "SavedSearches"
                "EE32E446-31CA-4ABA-814F-A5EBD2FD6D5E" = "SEARCH_CSC"
                "98EC0E18-2098-4D44-8644-66979315A281" = "SEARCH_MAPI"
                "190337D1-B8CA-4121-A639-6D472D16972A" = "SearchHome"
                "8983036C-27C0-404B-8F08-102D10DCFD74" = "SendTo"
                "7B396E54-9EC5-4300-BE0A-2482EBAE1A26" = "SidebarDefaultParts"
                "A75D362E-50FC-4FB7-AC2C-A8BEAA314493" = "SidebarParts"
                "625B53C3-AB48-4EC1-BA1F-A1EF4146FC19" = "StartMenu"
                "B97D20BB-F46A-4C97-BA10-5E3608430854" = "Startup"
                "43668BF8-C14E-49B2-97C9-747784D784B7" = "SyncManager"
                "289A9A43-BE44-4057-A41B-587A76D7E7F9" = "SyncResults"
                "0F214138-B1D3-4A90-BBA9-27CBC0C5389A" = "SyncSetup"
                "1AC14E77-02E7-4E5D-B744-2EB1AE5198B7" = "System"
                "D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27" = "SystemX86"
                "A63293E8-664E-48DB-A079-DF759E0509F7" = "Templates"
                "5B3749AD-B49F-49C1-83EB-15370FBD4882" = "TreeProperties"
                "0762D272-C50A-4BB0-A382-697DCD729B80" = "UserProfiles"
                "F3CE0F7C-4901-4ACC-8648-D5D44B04EF8F" = "UsersFiles"
                "18989B1D-99B5-455B-841C-AB7C74E4DDFC" = "Videos"
                "F38BF404-1D43-42F2-9305-67DE0B28FC23" = "Windows"
        }

        foreach($sid in $(Get-SIDs).SID){

            $GUIDS = (Get-ChildItem -Path "Registry::HKU\$sid\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist\" -ErrorAction SilentlyContinue).PSChildName
            foreach($guid in $GUIDs){

                Get-Item -Path "Registry::HKU\$sid\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist\$guid\Count" | Select-Object -ExpandProperty Property | % {
                    $PlainCharList = New-Object Collections.Generic.List[char] 
                    foreach($CipherChar in $_.ToCharArray()){
                        switch($CipherChar){
                            {$_ -ge 65 -and $_ -le 90} {$PlainCharList.Add((((($_ -65 -13) % 26 + 26) % 26) +65))}
                            {$_ -ge 97 -and $_ -le 122} {$PlainCharList.Add((((($_ -97 -13) % 26 + 26) % 26) + 97))}
                            default{$PlainCharList.Add($CipherChar)}
                        }
                    }

                    $ValueName = $PlainCharList -join ""

                    ######
                    $guidKnown = $guidPattern.Match($ValueName).value
                    $knownFolder=$GUIDKnownFolderHT[$guidKnown]
                
                    if ($knownFolder) {
                        $ValueName = $ValueName.Replace($guidKnown, $knownFolder)
                        $ValueName = $ValueName.Replace("{","")
                        $ValueName = $ValueName.replace("}","")
                    }



                    #####

                    $ValueContent = (gp "Registry::HKU\$sid\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist\$guid\Count" -Name $_).$_

                    $FileTime = switch($ValueContent.Count){
                         8 {[datetime]::FromFileTime(0)}

                        16{[datetime]::FromFileTime([BitConverter]::ToInt64($ValueContent[8..15],0))}

                        default{[datetime]::FromFileTime([BitConverter]::ToInt64($ValueContent[60..67],0))}
                    }

                    $property = [ordered]@{
                        "Last Execution Time"=$FileTime
                        "SID"=$sid
                        "UserName" = Convert-SIDToUser -SID $sid 
                        "Name"=$ValueName 
                    }

                    $record = New-Object -TypeName psobject -Property $property

                    $userAssistRecords += $record
                }
            }
        }
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-UserAssist Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    


    return $userAssistRecords
}

function Parse-InstalledPrograms{
    $softwares = @()

    try{
		Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" | Add-RegKeyLastWriteTime |  %{

            $property = [ordered]@{
                "InstallDate" = $_.LastWriteTime
                "UserName" = "Local Machine"
                "SID" = "Local Machine"
                "DisplayName" = $_.GetValue('DisplayName') 
                "DisplayVersion" = $_.GetValue('DisplayVersion') 
                "InstallSource" = $_.GetValue('InstallSource') 
                "InstallLocation" = $_.GetValue('InstallLocation') 
                "Publisher" = $_.GetValue('Publisher') 
                "DisplayIcon" = $_.GetValue('DisplayIcon') 
                "UninstallString" = $_.GetValue('UninstallString') 
            }
        
            $softwares += New-Object -TypeName psobject -Property $property
        }
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-InstalledPrograms Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    
    try{
	    Get-ChildItem -Path "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall" | Add-RegKeyLastWriteTime |  %{

            $property = [ordered]@{
                "InstallDate" = $_.LastWriteTime
                "UserName" = "Local Machine" 
                "SID" = "Local Machine"
                "DisplayName" = $_.GetValue('DisplayName') 
                "DisplayVersion" = $_.GetValue('DisplayVersion') 
                "InstallSource" = $_.GetValue('InstallSource') 
                "InstallLocation" = $_.GetValue('InstallLocation') 
                "Publisher" = $_.GetValue('Publisher') 
                "DisplayIcon" = $_.GetValue('DisplayIcon') 
                "UninstallString" = $_.GetValue('UninstallString') 
            }
        
            $softwares += New-Object -TypeName psobject -Property $property
        }
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-InstalledPrograms Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    

    Get-SIDs | %{

        try{
		    $sid = $_.SID

            Get-ChildItem -Path "Registry::HKU\$sid\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" —ErrorAction SilentlyContinue |  Add-RegKeyLastWriteTime |  % { 
                $property = [ordered]@{
                    "InstallDate" = $_.LastWriteTime
                    "UserName" = Convert-SIDToUser -SID $sid 
                    "SID" = $sid
                    "DisplayName" = $_.GetValue('DisplayName') 
                    "DisplayVersion" = $_.GetValue('DisplayVersion') 
                    "InstallSource" = $_.GetValue('InstallSource') 
                    "InstallLocation" = $_.GetValue('InstallLocation') 
                    "Publisher" = $_.GetValue('Publisher') 
                    "Displaylcon" = $_.GetValue('DisplayIcon') 
                    "UninstallString" = $_.GetValue('UninstallString') 
                }

                $softwares += New-Object -TypeName psobject -Property $property
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Parse-InstalledPrograms Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }

    return $softwares
}

function Parse-Amcache{
    try{
        $scriptPath = (Get-Location).Path

        New-Item -Path "$ProgramExecutionFolder\Amcache" -ItemType Directory -Force | Out-Null

        Push-Location $scriptPath
    }
    catch{
		# Handle specific errors here
		$errorMessage = "Parse-Amcache Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    

    try{
		if($config.'Forensic Action'.Parse -eq "yes"){./Dependencies/AmcacheParser.exe -f "C:\Windows\appcompat\Programs\Amcache.hve" -i --csv "$ProgramExecutionFolder\Amcache" --csvf Amcache.tle | Out-Null}	
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-Amcache Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    try{
		if($config.'Forensic Action'.Collect -eq "yes"){Copy-ProtectedFiles -SourcePath "C:\Windows\appcompat\Programs\Amcache.hve" -DestinationPath "$ProgramExecutionFolder\Amcache" | Out-Null}
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-Amcache Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    Pop-Location
}

function Get-PCA{
    #Program Compatibility Assistant (PCA) - Windows 11
    try{
		if($config.'Forensic Action'.Collect -eq "yes"){
            New-Item -Path "$ProgramExecutionFolder\Program Compatibility Assistant (PCA)" -ItemType Directory -Force | Out-Null

            Copy-ProtectedFiles -SourcePath "C:\Windows\appcompat\pca\PcaAppLaunchDic.txt" -DestinationPath "$ProgramExecutionFolder\Program Compatibility Assistant (PCA)" | Out-Null
            Copy-ProtectedFiles -SourcePath "C:\Windows\appcompat\pca\PcaGeneralDb0.txt" -DestinationPath "$ProgramExecutionFolder\Program Compatibility Assistant (PCA)" | Out-Null
            Copy-ProtectedFiles -SourcePath "C:\Windows\appcompat\pca\PcaGeneralDb1.txt" -DestinationPath "$ProgramExecutionFolder\Program Compatibility Assistant (PCA)" | Out-Null
        }
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Get-PCA Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
}

function Parse-Shimcache{
    $scriptPath = (Get-Location).Path

    Push-Location $scriptPath

    try{
		./Dependencies/AppCompatCacheParser.exe -t --csv $ProgramExecutionFolder --csvf Shimcache.tle | Out-Null
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-Shimcache Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    Pop-Location
}

function Parse-WordWheelQuery{
    $sids = $(Get-SIDs).SID
    $words = @()

    foreach($sid in $sids){
        
        try{
			Get-Item "Registry::HKU\$sid\Software\Microsoft\Windows\CurrentVersion\Explorer\WordWheelQuery" -ErrorAction SilentlyContinue | select -ExpandProperty property | %{
                $binary = [System.Text.Encoding]::Unicode.GetString((gp "Registry::HKU\$sid\Software\Microsoft\Windows\CurrentVersion\Explorer\WordWheelQuery" —ErrorAction SilentlyContinue).$_)
                $binary = $binary -replace '[^a-zA-Zא-ת0-9 \.\-_\\/()~:!@#$%^&;~]', '*'
                $result = $binary.replace('*','')
                $words += $result | Select @{name="SID";expression={$sid}},@{name="Username";expression={$(Convert-SIDToUser $sid)}},@{name="Word";expression={$result}}
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Parse-WordWheelQuery Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }
    return $words
}

function Parse-OfficeFileMRU{
    $sids = $(Get-SIDs).SID
    
    $documents = @()

    # Get Excel Values 
    foreach($sid in $sids){

        try{
			foreach($version in $versions){
                Get-Item "Registry::HKU\$sid\SOFTWARE\Microsoft\Office\$version\Excel\User MRU\ADAL*\File MRU" -ErrorAction SilentlyContinue | select -ExpandProperty property | %{

                    $value = (gp "Registry::HKU\$sid\SOFTWARE\Microsoft\Office\$version\Excel\User MRU\ADAL*\File MRU" -ErrorAction SilentlyContinue).$_
                    $VersionPath = $value.Split("*")[-1]
                    try{$OpenDate = [datetime]::FromFileTime([String]::Format("0x{0:x}", [regex]::Match($value,"\[.*\]\[(.*?)\]\[.*\].*").Groups[1].Value.Trim("T")))}
                    catch{$OpenDate = "Folder Has No Date"}
                    $property = [ordered]@{ 
                        "Open Date"=$OpenDate 
                        "Type"="Excel"
                        "User"=$(Convert-SIDToUser -SID $sid) 
                        "SID"=$sid
                        "Path"=$VersionPath
                    }


                    $documents += New-Object psobject -Property $property
                }
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Parse-OfficeFileMRU Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
        
        $versions = (Get-ChildItem "Registry::HKU\$sid\SOFTWARE\Microsoft\Office" -ErrorAction SilentlyContinue).PSChildName | ?{$_ -like "*.0"}

    }

    # Get PowerPoint Values 
    foreach($sid in $sids){
        $versions = (Get-ChildItem "Registry::HKU\$sid\SOFTWARE\Microsoft\Office" -ErrorAction SilentlyContinue).PSChildName | ?{$_ -like "*.0"}

        foreach($version in $versions){

            try{
			    Get-Item "Registry::HKU\$sid\SOFTWARE\Microsoft\Office\$version\PowerPoint\User MRU\ADAL*\File MRU" -ErrorAction SilentlyContinue | select -ExpandProperty property | %{
            
                    $value = (gp "Registry::HKU\$sid\SOFTWARE\Microsoft\Office\$version\PowerPoint\User MRU\ADAL*\File MRU" -ErrorAction SilentlyContinue).$_
                    $VersionPath = $value.Split("*")[-1]
                    try{$OpenDate = [datetime]::FromFileTime([String]::Format("0x{0:x}", [regex]::Match($value,"\[.*\]\[(.*?)\]\[.*\].*").Groups[1].Value.Trim("T")))}
                    catch{$OpenDate = "Folder Has No Date"}
                    $property = [ordered]@{ 
                        "Open Date"=$OpenDate 
                        "Type"="PowerPoint"
                        "User"=$(Convert-SIDToUser -SID $sid) 
                        "SID"=$sid
                        "Path"=$VersionPath
                    }


                    $documents += New-Object psobject -Property $property
                }
		    }
		    catch{
			    # Handle specific errors here
			    $errorMessage = "Parse-OfficeFileMRU Error: $($_.Exception.Message)"
		
			    # Append the error message to the error log file
			    Write-ErrorLog -Content $errorMessage
		    }
        }
    }

    # Get Word Values 
    foreach($sid in $sids){

        try{
			$versions = (Get-ChildItem "Registry::HKU\$sid\SOFTWARE\Microsoft\Office" -ErrorAction SilentlyContinue).PSChildName | ?{$_ -like "*.0"}

            foreach($version in $versions){
                Get-Item "Registry::HKU\$sid\SOFTWARE\Microsoft\Office\$version\Word\User MRU\ADAL*\File MRU" -ErrorAction SilentlyContinue | select -ExpandProperty property | %{

                    $value = (gp "Registry::HKU\$sid\SOFTWARE\Microsoft\Office\$version\Word\User MRU\ADAL*\File MRU" -ErrorAction SilentlyContinue).$_
                    $VersionPath = $value.Split("*")[-1]
                    try{$OpenDate = [datetime]::FromFileTime([String]::Format("0x{0:x}", [regex]::Match($value,"\[.*\]\[(.*?)\]\[.*\].*").Groups[1].Value.Trim("T")))}
                    catch{$OpenDate = "Folder Has No Date"}
                    $property = [ordered]@{ 
                        "Open Date"=$OpenDate 
                        "Type"="Word"
                        "User"=$(Convert-SIDToUser -SID $sid) 
                        "SID"=$sid
                        "Path"=$VersionPath
                    }


                    $documents += New-Object psobject -Property $property
                }
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Parse-OfficeFileMRU Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }
    return $documents
}

function Parse-ReadingLocations{
    $sids = $(Get-SIDs).SID

    $readingLocations = @() 
    foreach($sid in $sids){

        try{
			$versions = (Get-ChildItem "Registry::HKU\$sid\SOFTWARE\Microsoft\Office" -ErrorAction SilentlyContinue).PSChildName | ?{$_ -like "*.0"}

            foreach($version in $versions){
                Get-ChildItem "Registry::HKU\$sid\Software\Microsoft\Office\$version\Word\Reading Locations" —ErrorAction SilentlyContinue | Select -ExpandProperty Name | %{

                    $CloseTime = (gp "Registry::$_")."Datetime".Replace("T"," ")

                    $RegPath = (gp "Registry::$_")."File Path" 
            
                    $Position = (gp "Registry::$_")."Position"

                                            $property = [ordered]@{
                    "Close Time"=$CloseTime 
                    "User"=$(Convert-SIDToUser -SID $sid) 
                    "SID"=$sid
                    "Path"=$RegPath 
                    "Position"=$Position
                }
                    $readingLocations += New-Object psobject -Property $property
                }
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Parse-ReadingLocations Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
    }

    return $readingLocations
}

function Parse-MFT{

    try{
	   ./Dependencies/MFTECmd.exe -f "C:\`$MFT" --csv $FileUsageFolder --csvf "MFT.tle" --dt "yyyy-MM-dd HH:mm:ss" | Out-Null
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-MFT Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    Pop-Location
}

function Collect-MFT{

    try{
	   Copy-ProtectedFiles -SourcePath "C:0" -DestinationPath "$FileUsageFolder" | Out-Null
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Collect-MFT Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    
    Pop-Location

}

function Collect-USNJournal{

    $scriptPath = (Get-Location).Path

    Push-Location $scriptPath

    try{
	    ./Dependencies/ExtractUsnJrnl.exe /DevicePath:\\.\Harddisk0Partition2 /OutputPath:"$FileUsageFolder" | Out-Null
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Collect-USNJournal Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    Pop-Location
}

function Parse-Shellbags{

    $scriptPath = (Get-Location).Path

    Push-Location $scriptPath

    New-Item -ItemType Directory -Path $FileUsageFolder -Name Shellbags | Out-Null

    try{
	    ./Dependencies/SBECmd.exe -l --csv "$FileUsageFolder\Shellbags" --csvf ShellBags.tle | Out-Null
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-Shellbags Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    
    Pop-Location
}

function Get-WMIProviders{

    New-Item -ItemType Directory -Path "$PersistenceFolder\WMI Providers" -Force | Out-Null

    try{
		# Get WMI Event Consumers
        foreach ($NameSpace in "root\subscription","root\default") { Get-CimInstance -namespace $NameSpace -query "select * from __EventConsumer" | Select @{name="CreatorSID";expression={$_.CreatorSID -join ","}}, Name, SourceName,@{name="InsertionStringTemplates";expression={$_.InsertionStringTemplates -join ","}} | Export-Csv -Path "$PersistenceFolder\WMI Providers\WMI Event Consumers.tle" -Encoding UTF8 -Force -Append -NoTypeInformation}

        # Get WMI Event Filters
        foreach ($NameSpace in "root\subscription","root\default") { Get-CimInstance -Namespace $NameSpace -Query "select * from __EventFilter" | Select @{name="CreatorSID";expression={$_.CreatorSID -join ","}}, EventNamespace, Name,Query,QueryLanguage | Export-Csv -Path "$PersistenceFolder\WMI Providers\WMI Event Filters.tle" -Encoding UTF8 -Force -Append -NoTypeInformation}

        # Get WMI Filter to Consumer Binders
        foreach ($NameSpace in "root\subscription","root\default") {Get-CimInstance -Namespace $NameSpace -Query "select * from __FilterToConsumerBinding" | Select @{name="CreatorSID";expression={$_.CreatorSID -join ","}},Consumer,Filter | Export-Csv -Path "$PersistenceFolder\WMI Providers\WMI Filter Consumer Binders.tle" -Encoding UTF8 -Force -Append -NoTypeInformatiOn}
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Get-WMIProviders Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    
}

function Check-AccessibilityFeatures{
  
    $acc_path = "Registry::HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options"
    
    $features = @("sethc.exe", "utilman.exe", "AtBroker.exe", "Narrator.exe", "Magnify.exe", "DisplaySwitch.exe", "osk.exe")
    
    $content = "LastWriteTime, Feature, DebuggerExists, DebuggerValue, Valid File `n"
    
    foreach($feature in $features){

        try{
			$value = (gp "$acc_path\$feature" -Name Debugger -ErrorAction SilentlyContinue).Debugger
       
            $LastWriteTime = (Get-Item "$($acc_path)\$($feature)" -ErrorAction SilentlyContinue | Add-RegKeyLastWriteTime).LastWriteTime

            if($LastWriteTime -eq $null){
                $LastWriteTime = "Doesn't Exist"
            }
        
            $validation = sfc /VERIFYFILE=C:\Windows\System32\$feature
            $validation = $validation[5].Split("`0") -join ""

            if($validation -like "Windows Resource Protection did not find any integrity violations."){$validation = $true}
            else{$validation=$false}
        
            if($value){$content += "$LastWriteTime, $feature, True, $value, $validation `n"}
            else{$content += "$LastWriteTime, $feature, False, , $validation `n" }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Check-AccessibilityFeatures Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

    }
    $content | Set-Content "$PersistenceFolder\AccessibilityFeatures.tle"
}

function Get-PowershellHistory{
    $users = Get-Users

    New-Item -Path $ProgramExecutionFolder -Name "Powershell History" -ItemType Directory | Out-Null

    foreach($user in $users){
        Copy-Item -Path "C:\Users\$user\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt" -Destination "$ProgramExecutionFolder\Powershell History\$($user)_History.txt" -ErrorAction SilentlyContinue
    }
}

function Copy-UserStartupFolders{
    $users = Get-Users

    New-Item -Path $PersistenceFolder -Name "Startup Folders" -ItemType Directory | Out-Null

    foreach($user in $users){

        try{
			New-Item -Path "$PersistenceFolder\Startup Folders" -Name $user -ItemType Directory | Out-Null

            Copy-Item -Path "C:\Users\$user\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup" -Destination "$PersistenceFolder\Startup Folders\$user" -Recurse -ErrorAction SilentlyContinue
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-UserStartupFolders Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }
}

function Extract-Hives{
    $HivesPath = "C:\Windows\System32\config"

    $files = ("SAM","SAM.LOG1","SAM.LOG2","SOFTWARE","SOFTWARE.LOG1","SOFTWARE.LOG2","SYSTEM","SYSTEM.LOG1","SYSTEM.LOG2")

    $scriptPath = (Get-Location).Path

    Push-Location $scriptPath

    foreach($file in $files){
        try{
			Copy-ProtectedFiles -SourcePath "$HivesPath\$file" -DestinationPath "$RegistryHives" | Out-Null
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Extract-Hives Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
    }

    $users = Get-Users

    foreach($user in $users){

        try{
			$UserProfilePath = "C:\Users\$user"

            $UserClassPath = "C:\Users\$user\AppData\Local\Microsoft\Windows"
    
            New-Item -Path "$RegistryHives\User Hives" -ItemType Directory -Force | Out-Null

            New-Item -Path "$RegistryHives\User Hives\$user" -ItemType Directory -Force | Out-Null
    
            $userFiles = @("$UserProfilePath\NTUSER.DAT","$UserProfilePath\ntuser.dat.LOG1","$UserProfilePath\ntuser.dat.LOG2","$UserClassPath\UsrClass.DAT","$UserClassPath\UsrClass.dat.LOG1","$UserClassPath\UsrClass.dat.LOG2")
            foreach($userFile in $userFiles){
                Copy-ProtectedFiles -SourcePath $userFile -DestinationPath "$RegistryHives\User Hives\$user"
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Extract-Hives Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
    }

    Pop-Location
}

function Copy-MSSQLLogs{
    $paths = ("C:\Program Files\Microsoft SQL Server\MSSQL*\MSSQL\LOG\ERRORLOG*",
              "C:\Program Files (x86)\Microsoft SQL Server\MSSQL*\MSSQL\LOG\ERRORLOG*",
              "D:\Program Files\Microsoft SQL Server\MSSQL*\MSSQL\LOG\ERRORLOG*",
              "D:\Program Files (x86)\Microsoft SQL Server\MSSQL*\MSSQL\LOG\ERRORLOG*")

    foreach($sqlpath in $paths){

        try{
			if(Test-Path -Path $sqlpath){
                New-Item -ItemType Directory -Path $AdditionalFolder -ErrorAction SilentlyContinue | Out-Null
                New-Item -ItemType Directory -Path "$AdditionalFolder\SQL Logs" -ErrorAction SilentlyContinue | Out-Null  
                Get-ChildItem -Path $sqlpath -ErrorAction SilentlyContinue | %{
                    $fullPath = $_.FullName
                    Copy-Item -Path $fullPath -Destination "$AdditionalFolder\SQL Logs" -Force -ErrorAction SilentlyContinue
                }
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-MSSQLLogs Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }
}

function Copy-WmiExecOutput{

    $destinationDirectory = "$AdditionalFolder\WmiExec Output Files"

    # Regular expression pattern to match files like "__1443242.4234242"
    $pattern = "__\d+\.\d+"

    try{
        # Get the list of files that match the pattern in the source directory
        $filesToCopy = Get-ChildItem -Path $env:windir -File | Where-Object { $_.Name -match $pattern }

        if ($filesToCopy.Count -ne 0) {
            New-Item -Path $destinationDirectory -ItemType Directory -Force | Out-Null

            # Copy the files to the destination directory
            foreach ($file in $filesToCopy) {
                $destinationPath = Join-Path -Path $destinationDirectory -ChildPath $file.Name
                Copy-Item -Path $file.FullName -Destination $destinationPath -Force
            }
        }
    }
    catch{
		# Handle specific errors here
		$errorMessage = "Copy-WmiExecOutput Error: $($_.Exception.Message)"
		
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
}

function Copy-IISLogs{
    if(Test-Path -Path "$env:SystemDrive\inetpub\logs\LogFiles"){
        New-Item -ItemType Directory -Path $AdditionalFolder -ErrorAction SilentlyContinue | Out-Null
        New-Item -ItemType Directory -Path "$AdditionalFolder\IIS Logs" -ErrorAction SilentlyContinue | Out-Null  

        try{
			Copy-Item -Path "$env:SystemDrive\inetpub\logs\LogFiles" -Destination "$AdditionalFolder\IIS Logs" -Recurse -Force -ErrorAction SilentlyContinue
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-IISLogs Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }

}

function Extract-WinRARHistory{

    New-Item -Path $FileUsageFolder -Name "WinRAR History" -ItemType Directory -Force  | Out-Null

    $sids = $ProfileList.SID 

    foreach($sid in $sids){

        try{
			if(Test-Path -Path "Registry::HKU\$sid\Software\WinRAR\ArcHistory"){

                $user = $ProfileList | ?{$_.SID -eq "$sid"} | select -ExpandProperty "Username"

                New-Item -Path "$FileUsageFolder\WinRAR History" -Name $user -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null

                $paths = @("Path")

                (Get-Item -Path "Registry::HKU\$sid\Software\WinRAR\ArcHistory") | select -ExpandProperty Property | %{

                    $zipPath = (gp "Registry::HKU\$sid\Software\WinRAR\ArcHistory" -Name $_).$_

              
                    $paths += $zipPath


                }

                $paths

                $paths | Set-Content -Path "$FileUsageFolder\WinRAR History\$user\History.tle" -Force
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Extract-WinRARHistory Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }

}

function Extract-7ZipHistory{

    New-Item -Path $FileUsageFolder -Name "7-Zip History" -ItemType Directory -Force  | Out-Null

    $sids = $ProfileList.SID 

    foreach($sid in $sids){

        try{
			if(Test-Path -Path "Registry::HKU\$sid\Software\7-Zip\Compression\"){

                $user = $ProfileList | ?{$_.SID -eq "$sid"} | select -ExpandProperty "Username"

                New-Item -Path "$FileUsageFolder\7-Zip History" -Name $user -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null

                $bytes = (gp "Registry::HKU\$sid\Software\7-Zip\Compression\").ArcHistory

                $history = [System.Text.Encoding]::Unicode.GetString($bytes).Split([byte]0x00)

                $history = @("Path") + $history

                $history | Set-Content -Path "$FileUsageFolder\7-Zip History\$user\Archive History.tle" -Force
            }

            if(Test-Path -Path "Registry::HKU\$sid\Software\7-Zip\Extraction\"){

                $user = $ProfileList | ?{$_.SID -eq "$sid"} | select -ExpandProperty "Username"

                New-Item -Path "$FileUsageFolder\7-Zip History" -Name $user -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null

                $bytes = (gp "Registry::HKU\$sid\Software\7-Zip\Extraction\").PathHistory

                if($bytes){

                    $history = [System.Text.Encoding]::Unicode.GetString($bytes).Split([byte]0x00)

                    $history = @("Path") + $history
                }

                $history | Set-Content -Path "$FileUsageFolder\7-Zip History\$user\Extraction Path History.tle" -Force
            }

            if(Test-Path -Path "Registry::HKU\$sid\Software\7-Zip\FM\"){

                $user = $ProfileList | ?{$_.SID -eq "$sid"} | select -ExpandProperty "Username"

                New-Item -Path "$FileUsageFolder\7-Zip History" -Name $user -ItemType Directory -Force -ErrorAction SilentlyContinue | Out-Null

                $bytes = (gp "Registry::HKU\$sid\Software\7-Zip\FM\").CopyHistory

                if($bytes){
                    $history = [System.Text.Encoding]::Unicode.GetString($bytes).Split([byte]0x00)

                    $history = @("Path") + $history

                }

                $history | Set-Content -Path "$FileUsageFolder\7-Zip History\$user\Copy History.tle" -Force
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Extract-7ZipHistory Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }

}

function Parse-BAM{
    
    $executions = @()

    if(Test-Path -Path "Registry::HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\bam\State\UserSettings"){
    
        (Get-ChildItem "Registry::HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Services\bam\State\UserSettings").Name | %{

            try{
			    $key = $_

                $sid = Split-Path -Path $key -Leaf

                $user = $ProfileList | ?{$_.SID -eq "$sid"} | select -ExpandProperty "Username"

                (Get-Item "Registry::$key").Property | %{
        
                    if($_ -notlike "*SequenceNumber*" -and $_ -notlike "*Version*"){

                        $value = (Get-ItemProperty -Path "Registry::$key" -Name $_).$_

                        $time = [DateTime]::FromFileTimeutc([BitConverter]::ToInt64($value[0..8],0))

                        $time = Get-Date -Date $time -Format "dd-MM-yyyy HH:mm:ss"

                        $name = $_
            
                        $properties = [ordered]@{
                            "Execution Time"=$time
                            "Path"=$key
                            "Username"=$user
                            "Program"=$_
                        }

                        $executions += New-Object psobject -Property $properties

                
                    }
        
                }
		    }
		    catch{
			    # Handle specific errors here
			    $errorMessage = "Parse-BAM Error: $($_.Exception.Message)"
		
			    # Append the error message to the error log file
			    Write-ErrorLog -Content $errorMessage
		    }

            
    
        }

        $executions | Export-Csv -Path "$ProgramExecutionFolder\BAM.tle" -Force -Encoding UTF8 -NoTypeInformation
    }

}

function Get-RegDate{
    Param([String]$Path,[String]$Key)
    function GVl ($ar){
        return [uint32]('0x'+(($ar|ForEach-Object ToString X2) -join ''))
    }
    $Registry = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('LocalMachine', $env:COMPUTERNAME)
    $RegistryKey = $Registry.OpenSubKey($Path, $true)
    $ar = $RegistryKey.GetValue($Key)
    [System.Array]::Reverse($ar)
    $time = New-Object DateTime (GVl $ar[14..15]),(GVl $ar[12..13]),(GVl $ar[8..9]),(GVl $ar[6..7]),(GVl $ar[4..5]),(GVl $ar[2..3]),(GVl $ar[0..1])
    return $time
}

function Get-NetworkCardsConnections{
    $path = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles"

    $instances = (Get-ChildItem -Path $path -ErrorAction SilentlyContinue).PSChildName

    $networks = @()

    foreach($instanceId in $instances){
        $LastWriteTime = (Get-Item -Path "$path\$instanceId" | Add-RegKeyLastWriteTime).LastWriteTime 

        $networkProperty = Get-ItemProperty -Path "$path\$instanceId"
    
        $ProfileName = $networkProperty.ProfileName

        $Description = $networkProperty.Description

        $ConnectionType = $networkProperty.NameType

        Switch ($ConnectionType)
        {
            6 {$ConnectionType = "Wired (0x06)"}
            71 {$ConnectionType = "Wireless (0x47)"}
            23 {$ConnectionType = "Broadband 3G (0x17)"}
        }

        $trimmed_path = (Split-Path "$path" -NoQualifier).TrimStart("\")

        #$DateCreated =  Get-RegDate -Path "$trimmed_path\$instanceId" -Key "DateCreated"

        #$DateCreated = Get-Date -Date $DateCreated -Format "dd/MM/yyyy HH:mm:ss"

        $DateLastConnected = Get-RegDate -Path "$trimmed_path\$instanceId" -Key "DateLastConnected"

        $DateLastConnected = Get-Date $DateLastConnected -Format "dd/MM/yyyy HH:mm:ss"

        $networks += Get-ItemProperty -Path "$path\$instanceId" -ErrorAction SilentlyContinue | Select @{name="Date Created";expression={""}},@{name="Date Last Connected";expression={$DateLastConnected}},@{name="Profile Name";expression={$ProfileName}},@{name="Description";expression={$Description}},@{name="Connection Type";expression={$ConnectionType}}
    }

    return $networks
}

function Get-PuTTYSSHKeys{

    $sids = $(Get-SIDs).SID
    
    $logins = @()

    foreach($sid in $sids){

        try{
			$LastLoginTime = (Get-Item -Path "Registry::HKU\$sid\SOFTWARE\SimonTatham\PuTTY\SshHostKeys" -ErrorAction SilentlyContinue | Add-RegKeyLastWriteTime).LastWriteTime
        
            $sessions = Get-Item -Path "Registry::HKU\$sid\SOFTWARE\SimonTatham\PuTTY\SshHostKeys" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty property | %{
                $property = [ordered]@{
                    "Last Login Time"=$LastLoginTime
                    "User"=$(Convert-SIDToUser -SID $sid)
                    "SID"=$sid
                    "Value"=$_
                }
                $logins += New-Object psobject -Property $property
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-PuTTYSSHKeys Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
    
    }

    return $logins
}

function Get-WinSCPSSHKeys{

    $sids = $(Get-SIDs).SID
    
    $logins = @()

    foreach($sid in $sids){

        try{
			$LastLoginTime = (Get-Item -Path "Registry::HKU\$sid\SOFTWARE\Martin Prikryl\WinSCP 2\SshHostKeys" -ErrorAction SilentlyContinue | Add-RegKeyLastWriteTime).LastWriteTime
        
            $sessions = Get-Item -Path "Registry::HKU\$sid\SOFTWARE\Martin Prikryl\WinSCP 2\SshHostKeys" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty property | %{
                $property = [ordered]@{
                    "Last Login Time"=$LastLoginTime
                    "User"=$(Convert-SIDToUser -SID $sid)
                    "SID"=$sid
                    "Value"=$_
                }
                $logins += New-Object psobject -Property $property
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Get-WinSCPSSHKeys Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}

        
    }

    return $logins
}

function Copy-FileZillaFiles{

    $filezilla = Parse-InstalledPrograms | ?{$_.DisplayName -like "*FileZilla*"}

    if($filezilla){

        New-Item -ItemType Directory -Path $NetworkActivityFolder -Name "FileZilla Files"  -ErrorAction SilentlyContinue | Out-Null

        $users = Get-Users

        foreach($user in $users){

            try{
			    if(Test-Path -Path "C:\Users\$user\AppData\Roaming\FileZilla"){

                    New-Item -ItemType Directory -Path "$NetworkActivityFolder\FileZilla Files" -Name $user | Out-Null

                    Copy-Item -Path "C:\Users\$user\AppData\Roaming\FileZilla\*" -Destination "$NetworkActivityFolder\FileZilla Files\$user" -Force -Recurse
                }
		    }
		    catch{
			    # Handle specific errors here
			    $errorMessage = "Copy-FileZillaFiles Error: $($_.Exception.Message)"
		
			    # Append the error message to the error log file
			    Write-ErrorLog -Content $errorMessage
		    } 
        }
    }
}

function Copy-ActivitiesCache{

    New-Item -ItemType Directory -Path $ProgramExecutionFolder -Name "ActivitiesCache"  -ErrorAction SilentlyContinue | Out-Null

    $users = Get-Users

    foreach($user in $users){

        try{
			if(Test-Path -Path "C:\Users\$user\AppData\Local\ConnectedDevicesPlatform"){

                New-Item -ItemType Directory -Path "$ProgramExecutionFolder\ActivitiesCache" -Name $user | Out-Null

                Copy-Item -Path "C:\Users\$user\AppData\Local\ConnectedDevicesPlatform\*" -Destination "$ProgramExecutionFolder\ActivitiesCache\$user" -Force -Recurse
            }
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Copy-ActivitiesCache Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
    }
}

function Copy-AdditionalFiles{

    New-Item -ItemType Directory -Path $AdditionalFolder -ErrorAction SilentlyContinue | Out-Null

    if($config.'Additional Files'.Values){

        $config.'Additional Files'.Values | %{

            try{
                $file_path = $_

                $file_path = $file_path.Replace('"',"")

                $filename = Split-Path $file_path -Leaf
                
                if(Test-Path -Path $file_path){
                    if($file_path.EndsWith("\*")){
                        $file_path = $file_path.Substring(0, $file_path.Length - 2)
                        Copy-Item -Path $file_path -Destination $AdditionalFolder -Recurse -Force -ErrorAction SilentlyContinue
                    }
                    else{
                        Copy-Item -Path $file_path -Destination $AdditionalFolder -Force -ErrorAction SilentlyContinue
                    } 
                }
                else{
                    # Handle specific errors here
			        $errorMessage = "Copy-AdditionalFiles Error: Could not find file path $file_path"
		
			        # Append the error message to the error log file
			        Write-ErrorLog -Content $errorMessage
                }
			
		    }
		    catch{
			    # Handle specific errors here
			    $errorMessage = "Copy-AdditionalFiles Error: $($_.Exception.Message)"
		
			    # Append the error message to the error log file
			    Write-ErrorLog -Content $errorMessage
		    }
        }
    }
}

function Get-OneDrive{
    # Map OneDrive files on each user
    $users = Get-Users

    $oneDriveFiles = @()

    foreach($user in $users){
        Get-ChildItem -Path "C:\Users\$user\OneDrive" -Recurse -ErrorAction SilentlyContinue | %{
            try{
                $properties = [ordered]@{
                    Path=$_.FullName
                    Size=($_.Length | measure -Sum).sum / 1MB
                    "Creation Time"=$_.CreationTime
                    "Last Write Time"=$_.LastWriteTime
                }
                $oneDriveFiles += New-Object psobject -Property $properties
            }
            catch{
			    # Handle specific errors here
			    $errorMessage = "Get-OneDrive Error: $($_.Exception.Message)"
		
			    # Append the error message to the error log file
			    Write-Host $errorMessage
            }
            
        }
    }

    return $oneDriveFiles
}

function Copy-TeamViewerLogs{

    if(!(Test-Path -Path "C:\Program Files\TeamViewer") -and !(Test-Path -Path "C:\Program Files (x86)\TeamViewer")){
        return
    }

    $team_paths = @("C:\Program Files\TeamViewer\Connections_incoming.txt",
                    "C:\Program Files (x86)\TeamViewer\Connections_incoming.txt",
                    "C:\Program Files\TeamViewer\TeamViewer*.log",
                    "C:\Program Files (x86)\TeamViewer\TeamViewer*.log")

    New-Item -ItemType Directory -Path $AdditionalFolder -ErrorAction SilentlyContinue | Out-Null
    New-Item -ItemType Directory -Path "$AdditionalFolder\TeamViewer Logs" -ErrorAction SilentlyContinue | Out-Null  


    foreach($teamPath in $team_paths){
        Copy-Item -Path $teamPath -Destination "$AdditionalFolder\TeamViewer Logs" -Force -ErrorAction SilentlyContinue
    }

    $users = (Get-ChildItem -Path "C:\Users" -Exclude "Public","Default","All Users").Name

    foreach($user in $users){
        if(Test-Path -Path "C:\Users\$user\AppData\Roaming\TeamViewer"){
            New-Item -ItemType Directory -Path "$AdditionalFolder\TeamViewer Logs\$user" -ErrorAction SilentlyContinue | Out-Null
            Copy-Item -Path "C:\Users\$user\AppData\Roaming\TeamViewer\*" -Destination "$AdditionalFolder\TeamViewer Logs\$user" -Recurse -Force -ErrorAction SilentlyContinue
        }
    }
}

function Copy-AnyDeskLogs{

    if(!(Test-Path -Path "C:\ProgramData\AnyDesk")){
        return
    }

    New-Item -ItemType Directory -Path $AdditionalFolder -ErrorAction SilentlyContinue | Out-Null
    New-Item -ItemType Directory -Path "$AdditionalFolder\AnyDesk Logs" -ErrorAction SilentlyContinue | Out-Null
    Copy-Item -Path "C:\ProgramData\AnyDesk\*" -Destination "$AdditionalFolder\AnyDesk Logs" -Recurse -Force -ErrorAction SilentlyContinue

    $users = (Get-ChildItem -Path "C:\Users" -Exclude "Public","Default","All Users").Name

    foreach($user in $users){
        if(Test-Path -Path "C:\Users\$user\AppData\Roaming\AnyDesk"){
            New-Item -ItemType Directory -Path "$AdditionalFolder\AnyDesk Logs\$user" -ErrorAction SilentlyContinue | Out-Null
            Copy-Item -Path "C:\Users\$user\AppData\Roaming\AnyDesk\*" -Destination "$AdditionalFolder\AnyDesk Logs\$user" -Recurse -Force -ErrorAction SilentlyContinue
        }
        
    }
    
}

function Copy-MegaSyncFiles{

    if(!(Test-Path -Path "C:\ProgramData\AnyDesk")){
        return
    }

    New-Item -ItemType Directory -Path $AdditionalFolder -ErrorAction SilentlyContinue | Out-Null
    New-Item -ItemType Directory -Path "$AdditionalFolder\MegaSync Files" -ErrorAction SilentlyContinue | Out-Null 
    
    # A flag for the MegaSync folder existence
    $exists = $false 

    foreach($user in $users){
        if((Test-Path -Path "C:\Users\$user\AppData\Local\Mega Limited\MEGAsync\logs") -or (Test-Path -Path "C:\Users\$user\Documents\MEGAsync Downloads")){
            # Making sure there is a MegaSync folder
            $exists = $true
            New-Item -ItemType Directory -Path "$AdditionalFolder\MegaSync Files\$user" -ErrorAction SilentlyContinue | Out-Null
            New-Item -ItemType Directory -Path "$AdditionalFolder\MegaSync Files\$user\Downloads" -ErrorAction SilentlyContinue | Out-Null

            Copy-Item -Path "C:\Users\$user\AppData\Local\Mega Limited\MEGAsync\logs" -Destination "$AdditionalFolder\MegaSync Files\$user" -Recurse -Force -ErrorAction SilentlyContinue

            $downloads = @()
        
            Get-ChildItem "C:\Users\$user\Documents\MEGAsync Downloads" -Recurse -ErrorAction SilentlyContinue | %{
                $mega_path = $_.FullName
        
                $zoneIdentifier = Get-Content -Path $mega_path -Stream Zone.Identifier -ErrorAction SilentlyContinue
        
                $ZoneId = "-"
                $ReferrerUrl = "-"
                $HostUrl = "-"
        
                if($zoneIdentifier){
                            $zoneIdentifier = $zoneIdentifier -join "`n"
                
                            $ZoneIdRegex = [regex]::new(".*ZoneId=(.*)\n.*")
                            try{$ZoneId = $ZoneIdRegex.Matches($zoneIdentifier).Captures.Groups[1].Value}catch{$ZoneId="-"}
                
                            $ReferrerUrlRegex = [regex]::new(".*ReferrerUrl=(.*)\n.*")
                            try{$ReferrerUrl = $ReferrerUrlRegex.Matches($zoneIdentifier).Captures.Groups[1].Value}catch{$ZoneId="-"}
                
                            $HostUrlRegex = [regex]::new(".*HostUrl=(.*)")
                            try{$HostUrl = $HostUrlRegex.Matches($zoneIdentifier).Captures.Groups[1].Value}catch{$ZoneId="-"}
                        }
        
                $file_size = $_.Length / 1Mb
        
                $properties = [ordered]@{
                    "Directory"=$_.Directory
                    "File Name"=$_.PSChildName
                    "Zone Id"=$ZoneId
                    "Referrer URL"=$ReferrerUrl
                    "Host URL"=$HostUrl
                    "File Size (Mb)"=$file_size
                    "Creation Time"=$_.CreationTime
                    "Last Accesss Time"=$_.LastAccessTime
                    "Last Write Time"=$_.LastWriteTime
                }
        
                $downloads += New-Object psobject -Property $properties
            }
        
            $downloads | Export-Csv -Path "$AdditionalFolder\MegaSync Files\$user\Downloads\Downloads.tle" -Force -Encoding UTF8 -NoTypeInformation

            $size = (Get-ChildItem "C:\Users\$user\Documents\MEGAsync Downloads" -Recurse -ErrorAction SilentlyContinue | Measure-Object -Property Length -Sum).Sum
            if ($size -lt 100MB) {
                Copy-Item -Path "C:\Users\$user\Documents\MEGAsync Downloads" -Destination "$AdditionalFolder\MegaSync Files\$user\Downloads" -Recurse -Force -ErrorAction SilentlyContinue
            }

        }
    }

    if(!$exists){
        Remove-Item -Path "$AdditionalFolder\MegaSync Files" -Recurse -Force
    }
}

function Write-Log{
    Param([String]$Content)

    $Base = "[+] $(Get-Date -Format "dd/MM/yyyy HH:mm:ss") | "

    $FinalContent = $Base + $Content

    Add-Content -Path $LogPath -Value $FinalContent
    
}

function Write-ErrorLog{
    Param([String]$Content)

    $ErrorLogPath = "$GeneralPath\error.log"

    $Base = "[+] $(Get-Date -Format "dd/MM/yyyy HH:mm:ss") | "

    $FinalContent = $Base + $Content

    Add-Content -Path $ErrorLogPath -Value $FinalContent
}

function Compare-FolderWithZip{
    

    try{
		# Get the entries (files and folders) in the zip file
        $zipFiles = [System.IO.Compression.ZipFile]::OpenRead($ZipPath).Entries.FullName


        $folderItems = Get-ChildItem -Path $GeneralPath -Recurse | ForEach-Object {
                $_.FullName.Replace($GeneralPath, '').TrimStart('\')
        }
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Compare-FolderWithZip Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    $missingFiles = @()

    foreach($zipFile in $zipFiles){

        try{
		    if(!$folderItems.Contains($zipFile.TrimEnd("\")) -and (!$zipFile.ToLower().Contains("desktop.ini")) -and (!$zipFile.Contains("index.dat"))){
                $missingFiles += $zipFile
            }
	    }
	    catch{
		    # Handle specific errors here
		    $errorMessage = "Compare-FolderWithZip Error: $($_.Exception.Message)"
	
		    # Append the error message to the error log file
		    Write-ErrorLog -Content $errorMessage
	    }

        
    }

    Write-Log -Content "Missing Files:`n$($missingFiles -join "`n")"

    try{
		# Open the zip archive
        $zipArchive = [System.IO.Compression.ZipFile]::Open($ZipPath, [System.IO.Compression.ZipArchiveMode]::Update)

        $entryToDelete = Split-Path $LogPath -Leaf

        # Find the entry to delete
        $entry = (($zipArchive.Entries | Where-Object { $_.Name -eq $entryToDelete }).Delete()) | Out-Null

        # Delete Entry
        #$entry.Delete()

        # Add the new file to the archive
        [System.IO.Compression.ZipFileExtensions]::CreateEntryFromFile($zipArchive, $LogPath, (Split-Path $LogPath -Leaf))

        $zipArchive.Dispose()
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Compare-FolderWithZip Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}
    
}

function Parse-Config{

    try{
		# Read the configuration file
        $configFile = Get-Content -Path $ConfigPath
	}
	catch{
		# Handle specific errors here
		$errorMessage = "Parse-Config Error: $($_.Exception.Message)"
	
		# Append the error message to the error log file
		Write-ErrorLog -Content $errorMessage
	}

    

    # Process each line of the configuration file
    foreach ($line in $configFile) {
        if ($line -match '^\[(.*)\]$') {

            try{
			    # Matched section header
                $section = $matches[1]
                $config[$section] = @{}
		    }
		    catch{
			    # Handle specific errors here
			    $errorMessage = "Parse-Config Error: $($_.Exception.Message)"
		
			    # Append the error message to the error log file
			    Write-ErrorLog -Content $errorMessage
		    }

            
        }
        elseif ($line -match '^([^=]+)=(.*)$') {

            try{
			    # Matched key-value pair
                $key = $matches[1].Trim()
                $value = $matches[2].Trim()
                $config[$section][$key] = $value
		    }
		    catch{
			    # Handle specific errors here
			    $errorMessage = "Parse-Config Error: $($_.Exception.Message)"
		
			    # Append the error message to the error log file
			    Write-ErrorLog -Content $errorMessage
		    }

            
        }
    }

}

function Main{

    # Create Forensic Folders
    $foldersForCreation = @($GeneralPath,$SystemInformationFolder,$ProgramExecutionFolder,$FileDownloadFolder,$NetworkActivityFolder,$FileUsageFolder,$OfficeForensics,$USBUsageFolder,$BrowserUsageFolder,$PersistenceFolder,$RegistryHives,$AdditionalFolder)
    foreach($folder in $foldersForCreation){
        New-Item -ItemType Directory -Path $folder | Out-Null
    }
    
    # ----------------------------------------------------------------------------------------------------------------------

    # INITIAL #

    Write-Host $Intro -ForegroundColor Cyan

    $osVersion = (Get-CimInstance -ClassName Win32_OperatingSystem).Caption

    Add-Content -Path "$GeneralPath\$($env:COMPUTERNAME)-$($ProfileDate).log" -Value "PowerShell Version:$($PSVersionTable.PSVersion.Major)`nOS Version: $osVersion`nExecution Path: $GeneralPath`nUser Executed: $env:USERNAME`n"
    
    # Parse the config contents
    Parse-Config

    Write-Host "[+] | Initializing Forensic Analysis Process..." -ForegroundColor Cyan

    # Parse MFT
    if(($config.'File and Folder Usage'.'MFT Collect' -eq "yes") -and ($config.'Forensic Action'.Collect -eq "yes")){Write-Log -Content "Collecting Master File Table";Collect-MFT}
    if(($config.'File and Folder Usage'.'MFT Parse' -eq "yes") -and ($config.'Forensic Action'.Parse -eq "yes")){Write-Log -Content "Parsing Master File Table";Parse-MFT}

    # Save UsnJournal information *TAKES TIME*
    if($config.'File and Folder Usage'.UsnJournal -eq "yes"){
        
        if($config.'Forensic Action'.Collect -eq "yes"){
            Write-Log -Content "Collecting UsnJournal information"
            fsutil usn readJournal C: csv | Select-Object -Skip 7 | Out-File -FilePath "$FileUsageFolder\UsnJournal.tle" -Encoding UTF8 -Force
        }
        if($config.'Forensic Action'.Parse -eq "yes"){
            Write-Log -Content "Parsing UsnJournal information"
            fsutil usn readJournal C: csv | Select-Object -Skip 7 | Out-File -FilePath "$FileUsageFolder\UsnJournal.tle" -Encoding UTF8 -Force
            Collect-USNJournal
        }
    }

    # Load ntuser.dat of all users that ever logged to this machine
    Write-Log -Content "Loading ntuser.dat of all users that ever logged to this machine"
    Load-UserSids

    # Copy Event Logs *TAKES TIME*
    if($config.'Additional Artifacts'.'Event Logs' -eq "yes"){
        Write-Log -Content "Copying Event Logs" 
        Copy-EventLogs
    }

    Write-Host "[+] | Progress: 10% completed." -ForegroundColor Cyan

    # Extract Registry Hives - SYSTEM, SOFTWARE, SAM
    if($config.'Additional Artifacts'.'Registry Hives' -eq "yes"){
        Write-Log -Content "Extracting Registry Hives"
        Extract-Hives
    }

    # ----------------------------------------------------------------------------------------------------------------------

    # SYSTEM INFORMATION #
    # System Basic Information
    if($config.'System Information'.'System Information' -eq "yes"){
        Write-Log -Content "Collecting System Basic Information"
        Get-SystemInformation
    }

    # Process List
    if($config.'System Information'.Processes -eq "yes"){
        Write-Log -Content "Getting Process List"
        Get-WmiObject -Class Win32_Process | Select @{name="Creation Date";expression={[Management.ManagementDateTimeConverter]::ToDateTime($_.CreationDate)}},Caption,ExecutablePath,CommandLine,ProcessId,Description,Name,@{Name='UserName';Expression={$_.GetOwner().User}} | Export-Csv -Path "$SystemInformationFolder\Processes.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Process List with Services
    if($config.'System Information'.'Processes Including Service Names' -eq "yes"){
        Write-Log -Content "Getting Process List with Services"
        Tasklist /svc /FO csv  | Out-File -FilePath "$SystemInformationFolder\Processes Including ServiceName.tle" -Encoding UTF8 -Force
    }

    # All Process Hashes
    if($config.'System Information'.'Process Hashes' -eq "yes"){
        Write-Log -Content "Getting All Process Hashes"
        Get-ProcessHashes | Export-Csv -Path "$SystemInformationFolder\Process Hashes.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Drivers List
    if($config.'System Information'.Drivers -eq "yes"){
        Write-Log -Content "Getting Drivers List"
        Get-WmiObject -Class Win32_SystemDriver | Select DisplayName,Name,Description,State,PathName,ServiceType | Export-Csv -Path "$SystemInformationFolder\Drivers.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Drives
    if($config.'System Information'.Drives -eq "yes"){
        Write-Log -Content "Mapping Drives"
        Get-PSDrive | Select Name,Provider,Root,CurrentLocation | Export-Csv -Path "$SystemInformationFolder\Drives.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Get Local Users List
    if($config.'System Information'.'Local Users' -eq "yes"){
        Write-Log -Content "Getting Local Users List"
        Get-LocalUsers | Export-Csv -Path "$SystemInformationFolder\Local Users.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Get Local Group
    if($config.'System Information'.'Local Groups' -eq "yes"){
        Write-Log -Content "Getting Local Groups List"
        Get-LocalGroups | Export-Csv -Path "$SystemInformationFolder\Local Groups.tle" —NoTypeInformation -Force -Encoding UTF8
    }

    # Get Kerberos Tickets
    if($config.'System Information'.'Kerberos Tickets' -eq "yes"){
        Write-Log -Content "Getting Kerberos Tickets"
        klist | Out-File -FilePath "$SystemInformationFolder\Kerberos Tickets.txt" -Encoding UTF8 -Force
    }

    # Get Domain Information
    if($config.'System Information'.'Domain Information' -eq "yes"){
        Write-Log -Content "Getting Domain Information" 
        try{
			nltest /trusted_domains | Out-File -FilePath "$SystemInformationFolder\Domain Information.txt" -Encoding UTF8 -Force 2> $null
		}
		catch{
			# Handle specific errors here
			$errorMessage = "Domain Information Error: $($_.Exception.Message)"
		
			# Append the error message to the error log file
			Write-ErrorLog -Content $errorMessage
		}
        
    }

    Write-Log -Content "Finished Collecting System Information!"

    # ----------------------------------------------------------------------------------------------------------------------

    # PROGRAM EXECUTION #

    # Sysinternals Execution
    if($config.'Program Execution'.'Sysinternals Executions' -eq "yes"){
        Write-Log -Content "Parsing Sysinternals Execution"
        Get-SysinternalsExecution | Export-Csv -Path "$ProgramExecutionFolder\Sysinternals Executions.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Get Amcache Files
    if($config.'Program Execution'.'Amcache \ RecentFileCache' -eq "yes"){
        Write-Log -Content "Parsing Amcache"
        Parse-Amcache
    }

    # Get PCA Files
    if($config.'Program Execution'.'Program Compatibility Assistant (PCA)' -eq "yes"){
        Write-Log -Content "Getting Program Compatibility Assistant (PCA)"
        Get-PCA
    }

    # Parse JumpLists Files
    if($config.'Program Execution'.'Jump Lists' -eq "yes"){
        Write-Log -Content "Parsing Jump Lists"
        Parse-JumpLists
    }

    # Copy Prefetches
    if($config.'Program Execution'.Prefetches -eq "yes"){
        Write-Log -Content "Copying Prefetches"
        Copy-Item -Path $env:windir\Prefetch -Destination $ProgramExecutionFolder -ErrorAction SilentlyContinue -Recurse -Force
    }

    # Parse UserAssist Records from Registry
    if($config.'Program Execution'.UserAssist -eq "yes"){
        Write-Log -Content "Parsing UserAssist Records"
        Parse-UserAssist | Sort -Descending "Last Execution Time" | Export-Csv -Path "$ProgramExecutionFolder\UserAssist.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Parse Shimcache to find IOC
    if($config.'Program Execution'.Shimcache -eq "yes"){
        Write-Log -Content "Parsing Shimcache"
        if($config.'Forensic Action'.Parse -eq "yes"){Parse-Shimcache | Set-Content -Path "$ProgramExecutionFolder\Shimcache.tle"}
    }

    # Get Powershell History
    if($config.'Program Execution'.'Powershell History' -eq "yes"){
        Write-Log -Content "Getting Powershell History"
        Get-PowershellHistory
    }

    # Copy OBJECTS.DATA
    if($config.'Program Execution'.'WMI OBJECTS.DATA' -eq "yes"){
        Write-Log -Content "Copying OBJECTS.DATA"
        Copy-Item -Path "C:\Windows\System32\wbem\Repository\OBJECTS.DATA" -Destination $ProgramExecutionFolder -Force | Out-Null
    }

    # Copy ActivitiesCache.db
    if($config.'Program Execution'.ActivitiesCache -eq "yes"){
        Write-Log -Content "Copying ActivitiesCache"
        Copy-ActivitiesCache | Out-Null
    }

    # Parse BAM
    if($config.'Program Execution'.BAM -eq "yes"){
        Write-Log -Content "Parsing BAM"
        Parse-BAM
    }

    Write-Log -Content "Finished Collecting Program Execution!"

    Write-Host "[+] | Progress: 20% completed." -ForegroundColor Cyan

    # ----------------------------------------------------------------------------------------------------------------------

    # FILE DOWNLOAD #

    # Copy Downloads Folders
    if($config.'File Download'.'Downloads Folders' -eq "yes"){
        Write-Log -Content "Copying Downloads Folders"
        Copy-DownloadsFolder
    }

    # Parse Installed Programs
    if($config.'File Download'.'Installed Programs' -eq "yes"){
        Write-Log -Content "Parsing Installed Programs"
        Parse-InstalledPrograms | Export-Csv -Path "$FileDownloadFolder\Installed Programs.tle" -NoTypeInformation —Force -Encoding UTF8
    }

    Write-Log -Content "Finished Collecting Program File Download!"

    Write-Host "[+] | Progress: 30% completed." -ForegroundColor Cyan

    # ----------------------------------------------------------------------------------------------------------------------

    # NETWORK ACTIVITY #

    #$saruf = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String(""))
    #$saruf = $saruf -split ' ' |ForEach-Object {[char][byte]"0x$_"}
    #$saruf = $saruf -join ''

    # TCP Established Connections
    if($config.'Network Activity'.'TCP Connections' -eq "yes"){
        Write-Log -Content "Parsing TCP Connections"
        Get-TCPConnections | Export-Csv —Path "$NetworkActivityFolder\TCP Connections.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Interface Information
    Write-Log -Content "Collecting Interface Information"
    if($config.'Network Activity'.'Network Adapters' -eq "yes"){Get-NetAdapter | Select Name, Status, MacAddress, PhysicalMediaType, DriverName, DriverInformation, DriverVersion, DriverDescription, SystemName, PnPDeviceID | Export-Csv -Path "$NetworkActivityFolder\Network Adapters.tle" -NoTypeInformation -Force -Encoding UTF8}
    if($config.'Network Activity'.'Network IP Address' -eq "yes"){Get-NetIPAddress | Select IPAddress,InterfaceAlias,AddressFamily,Type,PrefixLength,PrefixOrigin,SuffixOrigin,AddressState | Export-Csv -Path "$NetworkActivityFolder\Network IP Address.tle" -NoTypeInformation —Force -Encoding UTF8}
    if($config.'Network Activity'.'Network IP Configuration' -eq "yes"){Get-NetIPConfiguration | Select InterfaceAlias,InterfaceIndex,InterfaceDescription,@{name="NetProfile";expression={$_.NetProfile.Name}},@{name="IPv4Address";expression={$_.IPv4Address -join ","}},@{name="IPv4DefaultGateway";expression={$_.IPv4DefaultGateway -join ","}},@{name="DNSServer";expression={$_.DNSServer -join ","}} | Export-Csv -Path "$NetworkActivityFolder\Network IP Configuration.tle" -NoTypeInformation -Force —Encoding UTF8}

    # Get Named Pipes
    if($config.'Network Activity'.'Named Pipes' -eq "yes"){
        Write-Log -Content "Getting Named Pipes"
        Get-ChildItem \\.\pipe\ | select FullName,IsReadOnly,Extension,Exists,Attributes,CreationTime,LastAccessTime,LastWriteTime | Export-Csv -Path "$NetworkActivityFolder\Named Pipes.tle" —Force -Encoding UTF8 —NoTypeInformation
    }

    # Copy hosts file
    if($config.'Network Activity'.'Hosts file' -eq "yes"){
        Write-Log -Content "Copying the hosts file"
        Copy-Item -Path "$env:windir\System32\drivers\etc\hosts" —Destination $NetworkActivityFolder —Force
    }

    # Network Share
    if($config.'Network Activity'.'Network Shares' -eq "yes"){
        Write-Log -Content "Mapping Network Shares"
        Get-WmiObject —Class Win32_Share | Select Name,Path,Description | Export-Csv -Path "$NetworkActivityFolder\Network Shares.tle" -NoTypeInformation -Force —Encoding UTF8
    }

    # Route Print
    if($config.'Network Activity'.'Route Print' -eq "yes"){
        Write-Log -Content "Running Route Print"
        route print | Out-File -FilePath "$NetworkActivityFolder\Route Print.tle" -Encoding UTF8 -Force
    }

    # ARP Table
    if($config.'Network Activity'.'ARP Table' -eq "yes"){
        Write-Log -Content "Collecting ARP Table"
        Get-NetNeighbor | ?{$_.AddressFamily -eq "IPv4"} | Select IPAddress,LinkLayerAddress,State | Export-Csv -Path "$NetworkActivityFolder\ARP Table.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Copy SRUDB which contains history of network connections
    if($config.'Network Activity'.SRUM -eq "yes"){
        Write-Log -Content "Parsing SRUDB which contains history of network connections"
        Parse-SRUM
    }

    # Get Active Sessions
    if($config.'Network Activity'.'Active Sessions' -eq "yes"){
        Write-Log -Content "Getting Active Sessions"
        qwinsta | Out-File -FilePath "$NetworkActivityFolder\Active Sessions.txt" -Encoding UTF8 -Force
    }

    # DNS Client Cache
    if($config.'Network Activity'.'DNS Client Cache' -eq "yes"){ 
        Write-Log -Content "Parsing DNS Client Cache" 
        Get-DnsClientCache | Select Entry,Name,Type,Status,Section,TimeToLive,DataLength,Data | Export-Csv -Path "$NetworkActivityFolder\DNS Client Cache.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # RDP Direct Connections
    if($config.'Network Activity'.'RDP Direct Connections' -eq "yes"){
        Write-Log -Content "Parsing RDP Direct Connections from Event Log"
        Get-RDPDirectConnectionsEventLog | Export-Csv -Path "$NetworkActivityFolder\RDP Direct Connections.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # RDP Connections in Registry
    if($config.'Network Activity'.'RDP Connections in Registry' -eq "yes"){
        Write-Log -Content "Parsing RDP Connections from Registry"
        Get-RDPConnectionsRegistry | Export-Csv -Path "$NetworkActivityFolder\RDP Connections in Registry.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # NetworkCards connections history
    if($config.'Network Activity'.'NetworkCards Connections' -eq "yes"){
        Write-Log -Content "Parsing NetworkCards connections history"
        
        try{Get-NetworkCardsConnections | Export-Csv -Path "$NetworkActivityFolder\NetworkCards Connections.tle" -NoTypeInformation -Force -Encoding UTF8}
        catch{
            # Handle specific errors here
            $errorMessage = "Get-NetworkCardsConnections Error: $($_.Exception.Message)"

            # Append the error message to the error log file
            Write-ErrorLog -Content $errorMessage

        }
    }

    # History of PuTTY SSH Connections from registry
    if($config.'Network Activity'.'PuTTY SSH Connections' -eq "yes"){
        Write-Log -Content "Getting PuTTY SSH connections history"
        Get-PuTTYSSHKeys | Export-Csv -Path "$NetworkActivityFolder\PuTTY SSH Connections.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # History of WinSCP Connections from registry
    if($config.'Network Activity'.'WinSCP Connections' -eq "yes"){
        Write-Log -Content "Getting WinSCP connections history"
        Get-WinSCPSSHKeys | Export-Csv -Path "$NetworkActivityFolder\WinSCP Connections.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Copying FileZilla files if exist
    if($config.'Network Activity'.'FileZilla Files' -eq "yes"){
        Write-Log -Content "Copying FileZilla files if exist"
        Copy-FileZillaFiles | Out-Null
    }

    Write-Log -Content "Finished Collecting Network Activity!"

    Write-Host "[+] | Progress: 40% completed." -ForegroundColor Cyan

    # ----------------------------------------------------------------------------------------------------------------------

    # FILE AND FOLDER USAGE #

    # Get Recent Documents Opened - Acquired from Registry
    if($config.'File and Folder Usage'.'Recent Documents - From Registry' -eq "yes"){
        Write-Log -Content "Getting Recent Documents Opened"
        Get-RecentDocs | Set-Content -Path "$FileUsageFolder\Recent Documents - From Registry.tle" -Force
    }

    # Run History
    if($config.'File and Folder Usage'.'WinkeyR History (Run)' -eq "yes"){
        Write-Log -Content "Running History"
        Get-WinkeyRHistory | Export-Csv -Path "$FileUsageFolder\WinkeyR History (Run).tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Copy Recent Files Folders
    if($config.'File and Folder Usage'.'Recent Folders' -eq "yes"){
        Write-Log -Content "Copying Recent Files Folders" 
        Copy-RecentFolders
    }

    # Copy All the Recycle Bins
    if($config.'File and Folder Usage'.'Recycle Bins folder and TLE file' -eq "yes"){
        Write-Log -Content "Parsing all Recycle Bin files" 
        Parse-RecycleBins | Export-Csv -Path "$FileUsageFolder\RecycleBin.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Copy Unsaved Office Files
    if($config.'Office Documents Usage'.'Unsaved Office Files' -eq "yes"){
        Write-Log -Content "Copying Unsaved Office Files" 
        Copy-UnsavedOfficeFiles
    }

    # Copy Temporary Burn Folders
    if($config.'File and Folder Usage'.'Temporary Burn Folders' -eq "yes"){
        Write-Log -Content "Copying Temporary Burn Folders"
        Copy-TemporaryBurnFolders
    }

    # Copy Files Opened From Outlook
    if($config.'Office Documents Usage'.'Outlook Opened Files Folder' -eq "yes"){
        Write-Log -Content "Copying Outlook Opened Files Folder"
        Copy-OutlookOpenedFiles
    }

    # Parse Office Documents History
    if($config.'Office Documents Usage'.'Office Documents History' -eq "yes"){
        Write-Log -Content "Parsing Office Documents History" 
        Parse-OfficeFileMRU | Export-Csv -Path "$OfficeForensics\Office Documents History.tle" —NoTypeInformation -Force -Encoding UTF8
    }

    # Parse Reading Locations - Close Times of Word Documents
    if($config.'Office Documents Usage'.ReadingLocations -eq "yes"){
        Write-Log -Content "Parsing Reading Locations" 
        Parse-ReadingLocations | Export-Csv -Path "$OfficeForensics\ReadingLocations.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Parse WordWheelQuery - All searches from "START" menu bar
    if($config.'File and Folder Usage'.WordWheelQuery -eq "yes"){
        Write-Log -Content "Parsing WordWheelQuery"
        Parse-WordWheelQuery | Export-Csv -Path "$FileUsageFolder\WordWheelQuery.tle" -NoTypeInformation —Force -Encoding UTF8
    }

    # Parse Shellbags
    if($config.'File and Folder Usage'.ShellBags -eq "yes"){
        Write-Log -Content "Parsing Shellbags" 
        if($config.'Forensic Action'.Parse -eq "yes"){Parse-Shellbags}
    }

    # Parse 7Zip History
    if($config.'File and Folder Usage'.'7-Zip History' -eq "yes"){
        Write-Log -Content "Parsing 7Zip History" 
        Extract-7ZipHistory
    }

    # Parse WinRAR History
    if($config.'File and Folder Usage'.'WinRAR History' -eq "yes"){
        Write-Log -Content "Parsing WinRAR History" 
        Extract-WinRARHistory
    }

    # Copying Temp Folders
    if($config.'File and Folder Usage'.'Temp Folders' -eq "yes"){
        Write-Log -Content "Listing Temp Folders" 
        Get-TempFolders
    }

    Write-Log -Content "Finished Collecting File and Folder Usage!"

    Write-Host "[+] | Progress: 50% completed." -ForegroundColor Cyan

    # ----------------------------------------------------------------------------------------------------------------------

    # USB AND EXTERNAL DEVICE USAGE #

    # Get USB History
    if($config.'USB and External Device Usage'.'USB History' -eq "yes"){
        Write-Log -Content "Getting USB History"
        Get-USBConnections | Export-Csv -Path "$USBUsageFolder\USB History.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Get Mount Points
    if($config.'USB and External Device Usage'.'Mount Points' -eq "yes"){
        Write-Log -Content "Getting Mount Points"
        Get-MountPoints | Export-Csv -Path "$USBUsageFolder\Mount Points.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Get Windows Portable Devices Connections
    if($config.'USB and External Device Usage'.'Windows Portable Devices' -eq "yes"){
        Write-Log -Content "Getting Windows Portable Devices Connections History"
        Get-WindowsPortableDevices | Export-Csv -Path "$USBUsageFolder\Windows Portable Devices.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    Write-Log -Content "Finished Collecting USB and External Device Usage"

    # ----------------------------------------------------------------------------------------------------------------------

    # BROWSER USAGE #

    # Copy All Chrome Information
    if($config.'Browser Usage'.'Chrome Files' -eq "yes"){
        Write-Log -Content "Copying all chrome information"
        Copy-ChromeFiles
    }

    # Copy All IE Files (WebCacheV01.dat)
    if($config.'Browser Usage'.'Internet Explorer Files' -eq "yes"){
        Write-Log -Content "Copying Internet Explorer Files"
        Copy-IEFiles
    }

    # Copy Firefox Files
    if($config.'Browser Usage'.'Firefox Files' -eq "yes"){
        Write-Log -Content "Copying Firefox Files"
        Copy-FirefoxFiles
    }

    # Copy Edge Files
    if($config.'Browser Usage'.'Edge Files' -eq "yes"){
        Write-Log -Content "Copying Edge Files"
        Copy-EdgeFiles
    }

    Write-Log -Content "Finished Collecting Browser Usage!"

    Write-Host "[+] | Progress: 60% completed." -ForegroundColor Cyan

    # ----------------------------------------------------------------------------------------------------------------------

    # PERSISTENCE ARTIFACTS #

    # Get detalls of all scheduled 
    if($config.'Persistence Artifacts'.'All Scheduled Tasks' -eq "yes"){
        Write-Log -Content "Getting details of all scheduled tasks"
        Get-AllScheduledTasks | Out-File -FilePath "$PersistenceFolder\All Scheduled Tasks.tle" -Encoding UTF8 -Force
    }

    # Service List
    if($config.'Persistence Artifacts'.Services -eq "yes"){
        Write-Log -Content "Getting Service List"
        Get-Services | Export-Csv -Path "$PersistenceFolder\Services.tle" -NoTypeInformation -Force -Encoding UTF8
    }

    # Autoruns
    if($config.'Persistence Artifacts'.Autoruns -eq "yes"){
        Write-Log -Content "Collecting Autoruns using Sysinternals Autoruns"
        if($config.'Forensic Action'.Parse -eq "yes"){Collect-Autoruns}
    }

    # WMI Providers
    if($config.'Persistence Artifacts'.'WMI Providers' -eq "yes"){
        Write-Log -Content "Getting WMI Providers"
        Get-WMIProviders
    }

    # Copy Start Menu Programs
    if($config.'Persistence Artifacts'.'Start Menu Programs' -eq "yes"){
        Write-Log -Content "Copying Start Menu Programs"
        Copy-Item -Path "C:\ProgramData\Microsoft\Windows\Start Menu\Programs" -Destination $PersistenceFolder -Recurse
    }

    # Copy User Startup Programs
    if($config.'Persistence Artifacts'.'User Startup Programs' -eq "yes"){
        Write-Log -Content "Copying User Startup Programs"
        Copy-UserStartupFolders
    }

    # Check Accessibility Features
    if($config.'Persistence Artifacts'.'Accessibility Features' -eq "yes"){
        Write-Log -Content "Checking Accessibility Features"
        Check-AccessibilityFeatures
    }

    Write-Log -Content "Finished Collecting Persistence!"

    Write-Host "[+] | Progress: 70% completed." -ForegroundColor Cyan

    # ----------------------------------------------------------------------------------------------------------------------

    # Cloud Forensics #

    #Write-Log -Content "Compressing Cloud Storage Files..."
    #Path-ToZip -File $CloudFolder

    #Write-Log -Content "Finished Collecting Cloud Storage Artifacts!"

    # ----------------------------------------------------------------------------------------------------------------------

    # ----------------------------------------------------------------------------------------------------------------------

    # ADDITIONAL #

    # Copy MSSQL Logs
    if($config.'Additional Artifacts','SQL Logs' -eq "yes"){
        Write-Log -Content "Copying MSSQL Log Files, if exist..."
        Copy-MSSQLLogs
    }

    # Copy IIS Logs
    if($config.'Additional Artifacts'.'IIS Logs' -eq "yes"){
        Write-Log -Content "Copying IIS Log Files, if exist..."
        Copy-IISLogs
    }

    # Copy TeamViewer Logs
    if($config.'Additional Artifacts'.'TeamViewer Logs' -eq "yes"){
        Write-Log -Content "Copying TeamViewer Log Files, if exist..."
        Copy-TeamViewerLogs
    }

    # Copy AnyDesk Logs
    if($config.'Additional Artifacts'.'AnyDesk Logs' -eq "yes"){
        Write-Log -Content "Copying AnyDesk Log Files, if exist..."
        Copy-AnyDeskLogs
    }
    
    # Copy MegaSync Files
    if($config.'Additional Artifacts'.'MegaSync Files' -eq "yes"){
        Write-Log -Content "Copying MegaSync Files, if exist..."
        Copy-MegaSyncFiles
    }

    # Copy WmiExec Output Files
    if($config.'Additional Artifacts'.'WmiExec Output Files' -eq "yes"){
        Write-Log -Content "Copying WmiExec Output Files, if exist..."
        Copy-WmiExecOutput
    }

    # Copy Additional Files
    Write-Log -Content "Copying additional files"
    Copy-AdditionalFiles
    Write-Host "[+] | Progress: 80% completed." -ForegroundColor Cyan

    # ----------------------------------------------------------------------------------------------------------------------

    # FINAL STEPS #
    # Unload the registry hives of the user sids
    Write-Log -Content "Unload the registry hives of the user sids"

    Unload-UserSids

    Write-Host "[+] | Progress: 90% completed." -ForegroundColor Cyan

    Write-Log -Content "Finished collecting and parsing all the artifacts"

    #Remove Empty Folders
    #Get-ChildItem -Path $GeneralPath -Recurse | % {
    #    $filepath = $_.FullName
    #    if((Get-ChildItem -Path $filepath | Measure-Object).Count -eq 0){
    #        Remove-Item $filepath -Force -Recurse
    #        $empty = $filepath.replace($GeneralPath,"")
    #        Write-Log -Content "Removed folder $empty for being empty"
    #    }
    #}

    #Compression
    try{
		Add-Type -AssemblyName System.IO.Compression.FileSystem

        [System.IO.Compression.ZipFile]::CreateFromDirectory($GeneralPath, $ZipPath)
    }
    catch{
	    # Handle specific errors here
	    $errorMessage = "Compression Error: $($_.Exception.Message)"

	    # Append the error message to the error log file
	    Write-ErrorLog -Content $errorMessage
    }

    Write-Log "Finished compressing the folder"

    # Making sure nothing is missing in the ZIP file
    Compare-FolderWithZip

    Write-Host "[!] | Finished collecting and parsing all the artifacts" -ForegroundColor Cyan

    Read-Host
}

# Ensure that script is running with administrative privileges
$admin = Check-AdminPrivileges

# Get the drive letter
$drive = Split-Path $GeneralPath -Qualifier

if(!$admin){Write-Host "[+] | The current execution is not running with Administrator privileges, crucial forensic data will not be collected.`nRestart this session and run as an administrator." -ForegroundColor Red}
elseif($drive -ne "C:"){Write-Host "[+] | Execution should be initiated from the C: drive" -ForegroundColor Red}
else{Main}